#!/usr/bin/env python3
"""
BYBIT COPY TRADING SYSTEM - –≠–¢–ê–ü 2: –°–ò–°–¢–ï–ú–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø
–í–µ—Ä—Å–∏—è 2.0 - –ü–†–û–§–ï–°–°–ò–û–ù–ê–õ–¨–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø

üéØ –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø –≠–¢–ê–ü–ê 2 –°–û–ì–õ–ê–°–ù–û –î–û–†–û–ñ–ù–û–ô –ö–ê–†–¢–ï:
- ‚úÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞–º–∏ —Å –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –æ—Ä–¥–µ—Ä–∞
- ‚úÖ –õ–æ–≥–∏–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π —Å Kelly Criterion –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ–º
- ‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π —Å –ø—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏–µ–π
- ‚úÖ Kelly Criterion implementation –¥–ª—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–ø–∏—Ç–∞–ª–æ–º
- ‚úÖ Trailing Stop-Loss System —Å ATR-based –∞–¥–∞–ø—Ç–∞—Ü–∏–µ–π
- ‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å –ø—Ä–æ—Å–∞–¥–∫–∏ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–æ–π

üîß –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –° –≠–¢–ê–ü–û–ú 1:
- ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç FinalTradingMonitor –∏–∑ enhanced_trading_system_final_fixed.py
- ‚úÖ –†–∞—Å—à–∏—Ä—è–µ—Ç ProductionSignalProcessor –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç—Å—è —Å FinalFixedWebSocketManager –¥–ª—è real-time –¥–∞–Ω–Ω—ã—Ö
- ‚úÖ –ü–æ–ª–Ω–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏ WebSocket —Ñ—É–Ω–∫—Ü–∏—è–º–∏
"""

import asyncio
import time
import json
import logging
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from enum import Enum
from collections import deque, defaultdict, namedtuple
import math
import statistics
from scipy.optimize import minimize_scalar
from scipy.stats import norm
import traceback
import uuid
from decimal import Decimal
import aiohttp

from app.sys_events_logger import sys_logger
from app.orders_logger import orders_logger, OrderStatus
from app.risk_events_logger import risk_events_logger, RiskEventType
from app.balance_snapshots_logger import balance_logger

logger = logging.getLogger(__name__)

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –∏–∑ –≠—Ç–∞–ø–∞ 1
try:
    from enhanced_trading_system_final_fixed import (
        FinalTradingMonitor, ProductionSignalProcessor, TradingSignal, SignalType,
        EnhancedBybitClient, FinalFixedWebSocketManager, 
        safe_float, send_telegram_alert, logger, MAIN_API_KEY, MAIN_API_SECRET,
        MAIN_API_URL, SOURCE_API_KEY, SOURCE_API_SECRET, SOURCE_API_URL
    )
    print("‚úÖ –£—Å–ø–µ—à–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≠—Ç–∞–ø–∞ 1")
except ImportError as e:
    print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≠—Ç–∞–ø–∞ 1: {e}")
    print("–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª enhanced_trading_system_final_fixed.py –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–π –∂–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏")
    raise

from risk_state_classes import RiskDataContext, HealthSupervisor


# ================================
# –ù–ê–°–¢–†–û–ô–ö–ò –ò –ö–û–ù–°–¢–ê–ù–¢–´ –≠–¢–ê–ü–ê 2
# ================================

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
COPY_CONFIG = {
    'default_copy_ratio': 1.0,              # –ë–∞–∑–æ–≤—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
    'min_copy_size': 0.001,                 # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–æ–ø–∏—Ä—É–µ–º–æ–π –ø–æ–∑–∏—Ü–∏–∏
    'max_copy_size': 10.0,                  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∫–æ–ø–∏—Ä—É–µ–º–æ–π –ø–æ–∑–∏—Ü–∏–∏
    'max_concurrent_positions': 10,         # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
    'sync_timeout': 5.0,                    # –¢–∞–π–º–∞—É—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    'order_retry_attempts': 3,              # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞
    'order_retry_delay': 1.0,               # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏
    'slippage_tolerance': 0.002,            # –î–æ–ø—É—Å—Ç–∏–º–æ–µ –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏–µ (0.2%)
    'market_impact_threshold': 0.05,        # –ü–æ—Ä–æ–≥ –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ —Ä—ã–Ω–æ–∫ (5%)
    'kelly_min_mult': 0.5,                  # Kelly –Ω–µ —É–º–µ–Ω—å—à–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –±–æ–ª–µ–µ —á–µ–º –≤ 2 —Ä–∞–∑–∞
    'kelly_max_mult': 2.0                   # –∏ –Ω–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –±–æ–ª–µ–µ —á–µ–º –≤ 2 —Ä–∞–∑–∞
}

# Kelly Criterion –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
KELLY_CONFIG = {
    'min_trades_required': 30,              # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞
    'lookback_window': 100,                 # –û–∫–Ω–æ –∞–Ω–∞–ª–∏–∑–∞ —Å–¥–µ–ª–æ–∫
    'confidence_threshold': 0.6,            # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤ —Ä–∞—Å—á–µ—Ç–∞—Ö
    'max_kelly_fraction': 0.25,             # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –ø–æ Kelly (25%)
    'conservative_factor': 0.5,             # –ö–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç (50% –æ—Ç Kelly)
    'min_position_size': 0.01,              # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (1%)
    'rebalance_threshold': 0.1              # –ü–æ—Ä–æ–≥ –¥–ª—è —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏ (10%)
}

# Trailing Stop-Loss –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
TRAILING_CONFIG = {
    'atr_period': 14,
    'atr_multiplier_conservative': 2.0,
    'atr_multiplier_moderate': 1.5,
    'atr_multiplier_aggressive': 1.0,
    'min_trail_distance': 0.005,
    'max_trail_distance': 0.05,
    'update_threshold': 0.001,
    'min_abs_move': 0.10,    # ‚úî –Ω–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∞–±—Å–æ–ª—é—Ç–Ω—ã–π —Å–¥–≤–∏–≥ —Ü–µ–Ω—ã (–≤ $) –¥–ª—è –∞–ø–¥–µ–π—Ç–∞
}

# –ö–æ–Ω—Ç—Ä–æ–ª—å —Ä–∏—Å–∫–æ–≤
RISK_CONFIG = {
    'max_daily_loss': 0.05,                # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–Ω–µ–≤–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ (5%)
    'max_total_drawdown': 0.15,            # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ (15%)      
    'position_correlation_limit': 0.7,     # –õ–∏–º–∏—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ –º–µ–∂–¥—É –ø–æ–∑–∏—Ü–∏—è–º–∏
    'max_exposure_per_symbol': 0.2,        # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —ç–∫—Å–ø–æ–∑–∏—Ü–∏—è –Ω–∞ —Å–∏–º–≤–æ–ª (20%)
    'emergency_stop_threshold': 0.1,       # –ü–æ—Ä–æ–≥ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ (10%)
    'recovery_mode_threshold': 0.08        # –ü–æ—Ä–æ–≥ —Ä–µ–∂–∏–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è (8%)
}

async def format_quantity_for_symbol_live(bybit_client, symbol: str, quantity: float, price: float = None) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω—ã—Ö –±–∏—Ä–∂–µ–≤—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤ Bybit.
    - –ï—Å–ª–∏ –Ω–µ –¥–æ—Ç—è–≥–∏–≤–∞–µ–º –¥–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ (min_notional) ‚Äî –ø–æ–¥–Ω–∏–º–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –í–í–ï–†–•.
    - –í–æ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö –æ–∫—Ä—É–≥–ª—è–µ–º –í–ù–ò–ó –∫ —à–∞–≥—É, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤—ã—à–∞—Ç—å —Ä–∏—Å–∫.
    """
    try:
        filters = await bybit_client.get_symbol_filters(symbol, category="linear")
        # –§–æ–ª–ª–±–µ–∫–∏ –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –±–∏—Ä–∂–∞ –Ω–µ –≤–µ—Ä–Ω—É–ª–∞ –∑–Ω–∞—á–µ–Ω–∏—è
        qty_step     = float(filters.get("qty_step") or 0.001)
        min_qty      = float(filters.get("min_qty") or 0.001)
        min_notional = float(filters.get("min_notional") or 10.0)

        decimals = 0
        # –æ—Ü–µ–Ω–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π –ø–æ —à–∞–≥—É
        if qty_step < 1:
            s = f"{qty_step:.12f}".rstrip('0')
            decimals = len(s.split('.')[-1]) if '.' in s else 0

        need_bump_to_min = False
        if price and price > 0:
            min_qty_by_value = float(min_notional) / float(price)
            effective_min    = max(min_qty, min_qty_by_value)
            if quantity < effective_min:
                quantity = effective_min
                need_bump_to_min = True

        steps = quantity / qty_step
        rounded_qty = (math.ceil(steps) * qty_step) if need_bump_to_min else (math.floor(steps) * qty_step)
        if rounded_qty < min_qty:
            rounded_qty = min_qty

        formatted = f"{rounded_qty:.{decimals}f}".rstrip('0').rstrip('.')
        logger.info(
            f"[live-format] {symbol}: qty_in={quantity:.8f} step={qty_step} "
            f"min_qty={min_qty} min_notional={min_notional} ‚Üí qty_out={formatted}"
        )
        return formatted or "0"
    except Exception as e:
        logger.warning(f"format_quantity_for_symbol_live fallback due to: {e}")
        # –§–æ–ª–ª–±–µ–∫: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–∂–Ω—é—é —Å—Ç–∞—Ç–∏—á–µ—Å–∫—É—é —Ñ—É–Ω–∫—Ü–∏—é, —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞—Ç—å
        return format_quantity_for_symbol(symbol, quantity, price)


def format_quantity_for_symbol(symbol: str, quantity: float, price: float = None) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å —É—á—ë—Ç–æ–º minNotional –∏ —à–∞–≥–∞ –ª–æ—Ç–∞.
    –ü—Ä–∞–≤–∏–ª–∞:
      - –µ—Å–ª–∏ –¥–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –ø–æ USDT –Ω–µ –¥–æ—Ç—è–≥–∏–≤–∞–µ–º ‚Äî –ø–æ–¥–Ω–∏–º–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –í–í–ï–†–•;
      - –∏–Ω–∞—á–µ –æ–∫—Ä—É–≥–ª—è–µ–º –í–ù–ò–ó –∫ —à–∞–≥—É, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤—ã—à–∞—Ç—å —Ä–∏—Å–∫.
    """
    MIN_ORDER_VALUE = 10.0  # –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç –¥–ª—è –ª–∏–Ω–µ–π–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤

    # –ë–∞–∑–æ–≤—ã–µ –ø—Ä–∞–≤–∏–ª–∞ —Ç–æ—á–Ω–æ—Å—Ç–∏ (–ª—É—á—à–µ —Ç—è–Ω—É—Ç—å —Å –±–∏—Ä–∂–∏ ‚Äî —Å–º. –º–µ—Ç–æ–¥ –≤ EnhancedBybitClient)
    SYMBOL_PRECISION = {
        'BTCUSDT':  {'min': 0.001, 'step': 0.001, 'decimals': 3},
        'ETHUSDT':  {'min': 0.001, 'step': 0.001, 'decimals': 3},  # ‚úî –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ
        'BNBUSDT':  {'min': 0.01,  'step': 0.01,  'decimals': 2},
        'XRPUSDT':  {'min': 1,     'step': 1,     'decimals': 0},
        'ADAUSDT':  {'min': 1,     'step': 1,     'decimals': 0},
        'DOGEUSDT': {'min': 1,     'step': 1,     'decimals': 0},
        'SOLUSDT':  {'min': 0.1,   'step': 0.1,   'decimals': 1},
        'DOTUSDT':  {'min': 0.1,   'step': 0.1,   'decimals': 1},
        'MATICUSDT':{'min': 1,     'step': 1,     'decimals': 0},
        'LTCUSDT':  {'min': 0.01,  'step': 0.01,  'decimals': 2},
        'AVAXUSDT': {'min': 0.1,   'step': 0.1,   'decimals': 1},
        'LINKUSDT': {'min': 0.1,   'step': 0.1,   'decimals': 1},
    }

    rules    = SYMBOL_PRECISION.get(symbol, {'min': 0.001, 'step': 0.001, 'decimals': 3})
    step     = rules['step']
    min_qty  = rules['min']
    decimals = rules['decimals']

    need_bump_to_min = False
    if price and price > 0:
        min_qty_by_value = MIN_ORDER_VALUE / float(price)
        effective_min     = max(min_qty, min_qty_by_value)
        if quantity < effective_min:
            quantity = effective_min
            need_bump_to_min = True

    steps = quantity / step
    rounded_qty = (math.ceil(steps) * step) if need_bump_to_min else (math.floor(steps) * step)
    if rounded_qty < min_qty:
        rounded_qty = min_qty

    formatted = f"{rounded_qty:.{decimals}f}".rstrip('0').rstrip('.')
    logger.info(
        f"Formatted quantity for {symbol}: {quantity:.6f} -> {formatted} "
        f"(price: ${float(price) if price else 0:.2f}, "
        f"value: {(float(formatted) * float(price)) if price else 0:.2f})"
    )
    return formatted


# ================================
# –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï ENUM –ò DATACLASS
# ================================

class CopyMode(Enum):
    DISABLED = "disabled"
    PROPORTIONAL = "proportional"
    KELLY_OPTIMAL = "kelly_optimal"
    FIXED_RATIO = "fixed_ratio"

class OrderStrategy(Enum):
    MARKET = "market"
    LIMIT = "limit"
    AGGRESSIVE_LIMIT = "aggressive_limit"
    ADAPTIVE = "adaptive"

class TrailingStyle(Enum):
    CONSERVATIVE = "conservative"
    MODERATE = "moderate"
    AGGRESSIVE = "aggressive"

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class MarketConditions:
    """–†—ã–Ω–æ—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞"""
    volatility: float = 0.0
    spread_percent: float = 0.0
    volume_ratio: float = 1.0
    trend_strength: float = 0.0
    liquidity_score: float = 1.0
    timestamp: float = field(default_factory=time.time)

@dataclass
class KellyCalculation:
    """–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å—á–µ—Ç–∞ Kelly Criterion"""
    symbol: str
    kelly_fraction: float
    win_rate: float
    avg_win: float
    avg_loss: float
    profit_factor: float
    sample_size: int
    confidence_score: float
    recommended_size: float
    timestamp: float = field(default_factory=time.time)

@dataclass
class TrailingStop:
    """Trailing Stop-Loss –¥–∞–Ω–Ω—ã–µ"""
    symbol: str
    side: str
    current_price: float
    stop_price: float
    distance: float
    distance_percent: float
    trail_style: TrailingStyle
    atr_value: float
    last_update: float = field(default_factory=time.time)

@dataclass
class CopyOrder:
    """–û—Ä–¥–µ—Ä –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
    source_signal: TradingSignal
    target_symbol: str
    target_side: str
    target_quantity: float
    target_price: Optional[float]
    order_strategy: OrderStrategy
    kelly_fraction: float
    priority: int
    retry_count: int = 0
    created_at: float = field(default_factory=time.time)
    metadata: Dict[str, Any] = field(default_factory=dict)

# ================================
# KELLY CRITERION IMPLEMENTATION
# ================================

class AdvancedKellyCalculator:
    """
    –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è Kelly Criterion –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–ø–∏—Ç–∞–ª–æ–º
    
    –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è—Ö:
    - John L. Kelly Jr. "A New Interpretation of Information Rate" (1956)
    - Edward Thorp "Beat the Dealer" (1962)
    - William Poundstone "Fortune's Formula" (2005)
    """
    
    def __init__(self):
        self.trade_history = deque(maxlen=KELLY_CONFIG['lookback_window'])
        self.symbol_stats = defaultdict(lambda: {'trades': [], 'last_update': 0})
        self.kelly_cache = {}
        self.cache_ttl = 300  # 5 –º–∏–Ω—É—Ç –∫—ç—à
        self.max_position_size = 0.25  # –ú–∞–∫—Å–∏–º—É–º 25% –∫–∞–ø–∏—Ç–∞–ª–∞ –Ω–∞ –ø–æ–∑–∏—Ü–∏—é
        self.min_position_size = 0.001  # –ú–∏–Ω–∏–º—É–º 0.1% –∫–∞–ø–∏—Ç–∞–ª–∞
        self.default_position_size = 0.02  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 2%
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        self.max_drawdown_threshold = 0.15  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ 15%
        self.kelly_multiplier = 0.5  # –ö–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –º–Ω–æ–∂–∏—Ç–µ–ª—å Kelly
        
        # –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—á–µ—Ç–æ–≤
        self.trade_history = deque(maxlen=100)
        self.performance_metrics = {
            'win_rate': 0.6,  # –ù–∞—á–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
            'avg_win': 0.02,  # 2% –≤ —Å—Ä–µ–¥–Ω–µ–º
            'avg_loss': 0.01,  # 1% –≤ —Å—Ä–µ–¥–Ω–µ–º
            'sharpe_ratio': 1.0
        }
        
        logger.info("Advanced Kelly Calculator initialized with safety limits")

    def apply_config(self, cfg: dict) -> None:
        """
        –ü—Ä–∏–º–µ–Ω—è–µ—Ç –Ω–æ–≤—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤ —Ä–∞–Ω—Ç–∞–π–º–µ.
        –°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –∫—ç—à–∏ –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –º–≥–Ω–æ–≤–µ–Ω–Ω–æ.

        Args:
            cfg: –°–ª–æ–≤–∞—Ä—å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ Kelly (–∏–∑ KELLY_CONFIG)
        """
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
            old_config = {
                'kelly_multiplier': self.kelly_multiplier,
                'max_position_size': self.max_position_size,
                'min_position_size': self.min_position_size,
                'max_drawdown_threshold': self.max_drawdown_threshold,
                'lookback_window': getattr(self.trade_history, 'maxlen', 100)
            }
        
            # –û–±–Ω–æ–≤–ª—è–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª–∏ –∏ –ª–∏–º–∏—Ç—ã
            self.kelly_multiplier = float(cfg.get('conservative_factor', self.kelly_multiplier))
            self.max_position_size = float(cfg.get('max_kelly_fraction', self.max_position_size))
            self.min_position_size = float(cfg.get('min_position_size', self.min_position_size))
            self.default_position_size = max(self.min_position_size, 0.001)
    
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Ä–æ–≥–∏
            self.max_drawdown_threshold = float(cfg.get('max_drawdown_threshold', 0.15))
    
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è
            new_lookback = int(cfg.get('lookback_window', 100))
            cache_cleared = False
            if new_lookback != getattr(self.trade_history, 'maxlen', new_lookback):
                from collections import deque
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –æ–∫–Ω–∞
                self.trade_history = deque(list(self.trade_history), maxlen=new_lookback)
                cache_cleared = True
        
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞
            self.kelly_cache.clear()
        
            # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            sys_logger.log_event(
                "INFO",
                "KellyCalculator",
                "Kelly configuration updated",
                {
                    "old_config": old_config,
                    "new_config": {
                        'kelly_multiplier': self.kelly_multiplier,
                        'max_position_size': self.max_position_size,
                        'min_position_size': self.min_position_size,
                        'max_drawdown_threshold': self.max_drawdown_threshold,
                        'lookback_window': new_lookback
                    },
                    "cache_cleared": cache_cleared
                }
            )
    
            logger.info(f"Kelly config applied: multiplier={self.kelly_multiplier}, "
                       f"max_size={self.max_position_size}, lookback={new_lookback}")
                   
        except Exception as e:
            sys_logger.log_error(
                "KellyCalculator",
                f"Failed to apply config: {str(e)}",
                {"config": cfg, "error": str(e)}
            )
            logger.error(f"Failed to apply Kelly config: {e}")
            raise

    def add_trade_result(self, symbol: str, pnl: float, trade_data: Dict[str, Any]):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å–¥–µ–ª–∫–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
        trade_record = {
            'symbol': symbol,
            'pnl': pnl,
            'pnl_percent': pnl / trade_data.get('position_value', 1),
            'timestamp': time.time(),
            'data': trade_data
        }
        
        self.trade_history.append(trade_record)
        self.symbol_stats[symbol]['trades'].append(trade_record)
        self.symbol_stats[symbol]['last_update'] = time.time()
        
        # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–∏–º–≤–æ–ª–∞ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å–¥–µ–ª–æ–∫)
        if len(self.symbol_stats[symbol]['trades']) > 100:
            self.symbol_stats[symbol]['trades'] = self.symbol_stats[symbol]['trades'][-100:]
        
        # –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à –¥–ª—è —Å–∏–º–≤–æ–ª–∞
        if symbol in self.kelly_cache:
            del self.kelly_cache[symbol]
    
    async def calculate_optimal_size(self, symbol: str, current_size: float, price: float, 
                                   balance: float = None, source_balance: float = None) -> Dict[str, Any]:
        """
        –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤–∞—à–µ–≥–æ –∫–ª–∞—Å—Å–∞ + —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
    
        Args:
            symbol: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª
            current_size: –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
            price: –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞
            balance: –ë–∞–ª–∞–Ω—Å —Ü–µ–ª–µ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            source_balance: –ë–∞–ª–∞–Ω—Å –∏—Å—Ç–æ—á–Ω–∏–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        
        Returns:
            Dict —Å —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–º —Ä–∞–∑–º–µ—Ä–æ–º –∏ –¥–µ—Ç–∞–ª—è–º–∏ —Ä–∞—Å—á–µ—Ç–∞
        """
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –º–æ—â–Ω—ã–π –º–µ—Ç–æ–¥ calculate_kelly_fraction
            estimated_balance = balance or current_size * price * 20  # –†–∞–∑—É–º–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
            kelly_calculation = self.calculate_kelly_fraction(symbol, estimated_balance)
        
            if kelly_calculation is None:
                # Fallback –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç
                fallback_fraction = await self.calculate_optimal_size(
                    balance=estimated_balance,
                    win_rate=self.performance_metrics['win_rate'],
                    avg_win=self.performance_metrics['avg_win'],
                    avg_loss=self.performance_metrics['avg_loss'],
                    current_drawdown=0.0
                )
                recommended_size = current_size * fallback_fraction * 5  # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
            
                return {
                    'success': True,
                    'recommended_size': recommended_size,
                    'kelly_fraction': fallback_fraction,
                    'confidence': 0.3,
                    'method': 'fallback_calculation',
                    'details': {
                        'original_size': current_size,
                        'reason': 'insufficient_data',
                        'scaling_factor': 5.0
                    }
                }
        
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤–∞—à–µ–≥–æ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–≥–æ Kelly —Ä–∞—Å—á–µ—Ç–∞
            base_kelly_size = kelly_calculation.recommended_size / price if price > 0 else current_size
        
            # –°–ü–ï–¶–ò–§–ò–ß–ï–°–ö–ò–ï –ö–û–†–†–ï–ö–¢–ò–†–û–í–ö–ò –î–õ–Ø –ö–û–ü–ò-–¢–†–ï–ô–î–ò–ù–ì–ê:
        
            # 1. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Å–∏–º–≤–æ–ª–∞ (–∏—Å–ø–æ–ª—å–∑—É—è –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ)
            volatility_factor = self._get_copy_volatility_adjustment(symbol, kelly_calculation)
        
            # 2. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –∫–∞–ø–∏—Ç–∞–ª–æ–≤
            if source_balance and balance:
                capital_ratio = balance / source_balance
                capital_adjustment = self._calculate_capital_adjustment(capital_ratio)
            else:
                capital_adjustment = 1.0
        
            # 3. –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞
            copy_limits = self._apply_copy_trading_limits(current_size, kelly_calculation.confidence_score)
        
            # –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç
            adjusted_size = base_kelly_size * volatility_factor * capital_adjustment
            final_size = max(copy_limits['min_size'], min(copy_limits['max_size'], adjusted_size))
        
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –æ—Ä–¥–µ—Ä–∞
            min_order_size = self._get_min_order_size(symbol)
            if final_size < min_order_size and current_size >= min_order_size:
                final_size = min_order_size
            elif final_size < min_order_size:
                final_size = 0  # –°–ª–∏—à–∫–æ–º –º–∞–ª–∞ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
        
            return {
                'success': True,
                'recommended_size': final_size,
                'kelly_fraction': kelly_calculation.kelly_fraction,
                'confidence': kelly_calculation.confidence_score,
                'method': 'advanced_kelly_copy_trading',
                'details': {
                    'original_size': current_size,
                    'base_kelly_size': base_kelly_size,
                    'volatility_factor': volatility_factor,
                    'capital_adjustment': capital_adjustment,
                    'final_size': final_size,
                    'kelly_data': {
                        'win_rate': kelly_calculation.win_rate,
                        'avg_win': kelly_calculation.avg_win,
                        'avg_loss': kelly_calculation.avg_loss,
                        'profit_factor': kelly_calculation.profit_factor,
                        'sample_size': kelly_calculation.sample_size
                    },
                    'copy_limits': copy_limits,
                    'min_order_size': min_order_size
                }
            }
        
        except Exception as e:
            logger.error(f"Enhanced Kelly copy calculation error for {symbol}: {e}")
        
            # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π fallback
            safe_size = current_size * 0.5  # 50% –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª–∞
            return {
                'success': False,
                'recommended_size': safe_size,
                'kelly_fraction': self.default_position_size,
                'confidence': 0.0,
                'method': 'error_fallback',
                'error': str(e),
                'details': {
                    'original_size': current_size,
                    'fallback_ratio': 0.5
                }
            }

    def calculate_kelly_fraction(self, symbol: str, current_balance: float) -> Optional[KellyCalculation]:
        """
        –†–∞—Å—á–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–∏ –ø–æ Kelly Criterion
    
        –§–æ—Ä–º—É–ª–∞: f = (bp - q) / b
        –≥–¥–µ:
        f = –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –¥–æ–ª—è –∫–∞–ø–∏—Ç–∞–ª–∞
        b = –æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ä–µ–¥–Ω–µ–π –ø—Ä–∏–±—ã–ª–∏ –∫ —Å—Ä–µ–¥–Ω–µ–π —É–±—ã—Ç–∫—É
        p = –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤—ã–∏–≥—Ä—ã—à–∞
        q = –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø—Ä–æ–∏–≥—Ä—ã—à–∞ (1-p)
        """
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
            cache_key = f"{symbol}_{current_balance}"
            if cache_key in self.kelly_cache:
                cached_result, cache_time = self.kelly_cache[cache_key]
                if time.time() - cache_time < self.cache_ttl:
                    return cached_result
        
            # –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é —Å–¥–µ–ª–æ–∫ –¥–ª—è —Å–∏–º–≤–æ–ª–∞
            symbol_trades = self.symbol_stats[symbol]['trades']
        
            if len(symbol_trades) < KELLY_CONFIG['min_trades_required']:
                logger.debug(f"Insufficient trade history for {symbol}: {len(symbol_trades)} trades")
                return self._default_kelly_calculation(symbol, current_balance)
        
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–¥–µ–ª–æ–∫
            pnl_values = [trade['pnl_percent'] for trade in symbol_trades]
            wins = [pnl for pnl in pnl_values if pnl > 0]
            losses = [abs(pnl) for pnl in pnl_values if pnl < 0]
        
            if not wins or not losses:
                logger.debug(f"No wins or losses for {symbol}")
                return self._default_kelly_calculation(symbol, current_balance)
        
            # –û—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            win_rate = len(wins) / len(pnl_values)
            avg_win = np.mean(wins)
            avg_loss = np.mean(losses)
        
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
            profit_factor = (avg_win * len(wins)) / (avg_loss * len(losses))
            max_drawdown = self._calculate_max_drawdown(pnl_values)
            sharpe_ratio = self._calculate_sharpe_ratio(pnl_values)
        
            # Kelly —Ä–∞—Å—á–µ—Ç
            b = avg_win / avg_loss  # –û—Ç–Ω–æ—à–µ–Ω–∏–µ –ø—Ä–∏–±—ã–ª–∏ –∫ —É–±—ã—Ç–∫—É
            p = win_rate
            q = 1 - p
        
            kelly_fraction = (b * p - q) / b
            raw_kelly = kelly_fraction  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–ø—Ä–∞–≤–∫–∏
            adjusted_kelly = self._apply_kelly_adjustments(
                kelly_fraction, win_rate, profit_factor, max_drawdown, 
                sharpe_ratio, len(pnl_values)
            )
        
            # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –µ—Å–ª–∏ Kelly –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–º–µ–Ω—å—à–µ–Ω
            if adjusted_kelly < raw_kelly * 0.8 and current_balance > 0:
                risk_events_logger.log_kelly_adjustment(
                    account_id=2,
                    original_size=current_balance * raw_kelly,
                    adjusted_size=current_balance * adjusted_kelly,
                    kelly_fraction=adjusted_kelly
                )
        
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            recommended_value = current_balance * adjusted_kelly
        
            # –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            result = KellyCalculation(
                symbol=symbol,
                kelly_fraction=adjusted_kelly,
                win_rate=win_rate,
                avg_win=avg_win,
                avg_loss=avg_loss,
                profit_factor=profit_factor,
                sample_size=len(pnl_values),
                confidence_score=self._calculate_confidence_score(len(pnl_values), sharpe_ratio),
                recommended_size=recommended_value
            )
        
            # –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            self.kelly_cache[cache_key] = (result, time.time())
        
            logger.info(f"Kelly calculation for {symbol}: fraction={adjusted_kelly:.3f}, size=${recommended_value:.2f}")
            return result
        
        except Exception as e:
            logger.error(f"Kelly calculation error for {symbol}: {e}")
            return self._default_kelly_calculation(symbol, current_balance)
    
    def _apply_kelly_adjustments(self, kelly_fraction: float, win_rate: float, 
                                profit_factor: float, max_drawdown: float, 
                                sharpe_ratio: float, sample_size: int) -> float:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–æ–∫ –∫ –±–∞–∑–æ–≤–æ–º—É Kelly –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—É"""
        
        adjusted_kelly = kelly_fraction
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ —Ä–∞–∑–º–µ—Ä –≤—ã–±–æ—Ä–∫–∏
        if sample_size < 50:
            confidence_factor = sample_size / 50
            adjusted_kelly *= confidence_factor
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø—Ä–æ—Å–∞–¥–∫—É
        if max_drawdown > 0.2:  # –ë–æ–ª–µ–µ 20%
            drawdown_factor = 0.2 / max_drawdown
            adjusted_kelly *= drawdown_factor
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ Sharpe ratio
        if sharpe_ratio < 1.0:
            sharpe_factor = max(0.5, sharpe_ratio)
            adjusted_kelly *= sharpe_factor
        
        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ Profit Factor
        if profit_factor < 1.2:  # PF –º–µ–Ω–µ–µ 1.2 —Å—á–∏—Ç–∞–µ—Ç—Å—è —Å–ª–∞–±—ã–º
            pf_factor = max(0.5, profit_factor / 1.2)
            adjusted_kelly *= pf_factor
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
        adjusted_kelly *= KELLY_CONFIG['conservative_factor']
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
        adjusted_kelly = min(adjusted_kelly, KELLY_CONFIG['max_kelly_fraction'])
        
        # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
        adjusted_kelly = max(adjusted_kelly, KELLY_CONFIG['min_position_size'])
        
        return adjusted_kelly
    
    def _calculate_max_drawdown(self, returns: List[float]) -> float:
        """–†–∞—Å—á–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ—Å–∞–¥–∫–∏"""
        try:
            cumulative = np.cumprod([1 + r for r in returns])
            running_max = np.maximum.accumulate(cumulative)
            drawdown = (cumulative - running_max) / running_max
            return abs(np.min(drawdown))
        except:
            return 0.0
    
    def _calculate_sharpe_ratio(self, returns: List[float]) -> float:
        """–†–∞—Å—á–µ—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –®–∞—Ä–ø–∞"""
        try:
            if len(returns) < 2:
                return 0.0
            mean_return = np.mean(returns)
            std_return = np.std(returns)
            if std_return == 0:
                return 0.0
            return mean_return / std_return
        except:
            return 0.0
    
    def _calculate_confidence_score(self, sample_size: int, sharpe_ratio: float) -> float:
        """–†–∞—Å—á–µ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –≤ —Ä–∞—Å—á–µ—Ç–∞—Ö"""
        # –ë–∞–∑–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞–∑–º–µ—Ä–∞ –≤—ã–±–æ—Ä–∫–∏
        size_confidence = min(1.0, sample_size / 100)
        
        # –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–∞—á–µ—Å—Ç–≤–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        quality_confidence = min(1.0, max(0.2, sharpe_ratio / 2.0))
        
        return (size_confidence + quality_confidence) / 2
    
    def _default_kelly_calculation(self, symbol: str, current_balance: float) -> KellyCalculation:
        """–î–µ—Ñ–æ–ª—Ç–Ω—ã–π —Ä–∞—Å—á–µ—Ç Kelly –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö"""
        return KellyCalculation(
            symbol=symbol,
            kelly_fraction=KELLY_CONFIG['min_position_size'],
            win_rate=0.5,
            avg_win=0.01,
            avg_loss=0.01,
            profit_factor=1.0,
            sample_size=0,
            confidence_score=0.1,
            recommended_size=current_balance * KELLY_CONFIG['min_position_size']
        )
    
    def get_portfolio_kelly_allocation(self, symbols: List[str], current_balance: float) -> Dict[str, KellyCalculation]:
        """–†–∞—Å—á–µ—Ç Kelly —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–ª—è –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å–∏–º–≤–æ–ª–æ–≤"""
        results = {}
        total_kelly = 0.0
        
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º Kelly –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–º–≤–æ–ª–∞
        for symbol in symbols:
            kelly_calc = self.calculate_kelly_fraction(symbol, current_balance)
            if kelly_calc:
                results[symbol] = kelly_calc
                total_kelly += kelly_calc.kelly_fraction
        
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –µ—Å–ª–∏ –æ–±—â–∏–π Kelly –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç
        if total_kelly > KELLY_CONFIG['max_kelly_fraction']:
            normalization_factor = KELLY_CONFIG['max_kelly_fraction'] / total_kelly
            for symbol in results:
                results[symbol].kelly_fraction *= normalization_factor
                results[symbol].recommended_size *= normalization_factor
        
        return results
    
    def _get_copy_volatility_adjustment(self, symbol: str, kelly_calc: KellyCalculation) -> float:
        """–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞"""
        # –ë–∞–∑–æ–≤–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ç–∏–ø—É –∞–∫—Ç–∏–≤–∞
        if 'BTC' in symbol:
            base_factor = 0.9  # BTC –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å—Ç–∞–±–∏–ª–µ–Ω
        elif symbol in ['ETHUSDT', 'ADAUSDT', 'SOLUSDT']:
            base_factor = 0.8  # –ö—Ä—É–ø–Ω—ã–µ –∞–ª—å—Ç–∫–æ–∏–Ω—ã
        elif 'USDT' in symbol:
            base_factor = 0.7  # –ú–µ–ª–∫–∏–µ –∞–ª—å—Ç–∫–æ–∏–Ω—ã –±–æ–ª–µ–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω—ã
        else:
            base_factor = 0.8  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é
    
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        if kelly_calc.sample_size > 50:
            # –ï—Å–ª–∏ –º–Ω–æ–≥–æ –¥–∞–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            if kelly_calc.avg_loss > 0.03:  # –í—ã—Å–æ–∫–∏–µ –ø–æ—Ç–µ—Ä–∏ = –≤—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
                base_factor *= 0.8
            elif kelly_calc.avg_loss < 0.01:  # –ù–∏–∑–∫–∏–µ –ø–æ—Ç–µ—Ä–∏ = –Ω–∏–∑–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
                base_factor *= 1.1
    
        return min(1.0, base_factor)

    def _calculate_capital_adjustment(self, capital_ratio: float) -> float:
        """–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ –∫–∞–ø–∏—Ç–∞–ª–æ–≤"""
        if capital_ratio > 1:
            # –ë–æ–ª—å—à–µ –∫–∞–ø–∏—Ç–∞–ª–∞ = –º–æ–∂–µ–º –ø–æ–∑–≤–æ–ª–∏—Ç—å —á—É—Ç—å –±–æ–ª—å—à–µ, –Ω–æ –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ
            return min(1.3, 1 + (capital_ratio - 1) * 0.15)
        else:
            # –ú–µ–Ω—å—à–µ –∫–∞–ø–∏—Ç–∞–ª–∞ = –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –º–µ–Ω—å—à–µ
            return max(0.5, capital_ratio)

    def _apply_copy_trading_limits(self, source_size: float, confidence: float) -> Dict[str, float]:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞"""
    
        # –ë–∞–∑–æ–≤—ã–µ –ª–∏–º–∏—Ç—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
        if confidence > 0.8:
            max_ratio = 2.5  # –í—ã—Å–æ–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å = –º–æ–∂–µ–º –±–æ–ª—å—à–µ
            min_ratio = 0.3
        elif confidence > 0.5:
            max_ratio = 1.5  # –°—Ä–µ–¥–Ω—è—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            min_ratio = 0.2
        else:
            max_ratio = 1.0  # –ù–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å = –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω–æ
            min_ratio = 0.1
    
        return {
            'max_size': source_size * max_ratio,
            'min_size': source_size * min_ratio
        }

    def _get_min_order_size(self, symbol: str) -> float:
        """–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –æ—Ä–¥–µ—Ä–æ–≤ –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        min_sizes = {
            'BTCUSDT': 0.0001,
            'ETHUSDT': 0.001,
            'ADAUSDT': 1.0,
            'SOLUSDT': 0.01,
            'DOGEUSDT': 10.0,
            'AVAXUSDT': 0.01,
            'DOTUSDT': 0.1,
            'LINKUSDT': 0.01,
            'UNIUSDT': 0.01,
            'LTCUSDT': 0.001
        }
        return min_sizes.get(symbol, 0.001)  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é

    # ============================================
    # –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ô –ú–ï–¢–û–î –î–õ–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ò –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø
    # ============================================

    def add_copy_trade_result(self, symbol: str, source_size: float, copied_size: float, 
                             pnl: float, trade_data: Dict[str, Any]):
        """
        –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –≤–∞—à–µ–≥–æ –º–µ—Ç–æ–¥–∞ add_trade_result –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞
        """
        copy_ratio = copied_size / source_size if source_size > 0 else 1
    
        # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞
        enhanced_trade_data = trade_data.copy()
        enhanced_trade_data.update({
            'source_size': source_size,
            'copied_size': copied_size,
            'copy_ratio': copy_ratio,
            'copy_efficiency': pnl / (copied_size * trade_data.get('avg_price', 1)) if copied_size > 0 else 0,
            'copy_type': 'copy_trade'
        })
    
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–∞—à —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –º–µ—Ç–æ–¥
        self.add_trade_result(symbol, pnl, enhanced_trade_data)

    def get_copy_trading_stats(self) -> Dict[str, Any]:
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        copy_trades = []
    
        # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–æ–ø–∏-—Ç—Ä–µ–π–¥–∏–Ω–≥–∞ –∏–∑ –æ–±—â–µ–π –∏—Å—Ç–æ—Ä–∏–∏
        for trade in self.trade_history:
            if trade.get('data', {}).get('copy_type') == 'copy_trade':
                copy_trades.append(trade)
    
        if not copy_trades:
            return {'message': 'No copy trading data available'}
    
        total_trades = len(copy_trades)
        winning_trades = len([t for t in copy_trades if t['pnl'] > 0])
    
        copy_ratios = [t['data']['copy_ratio'] for t in copy_trades if 'copy_ratio' in t['data']]
        avg_copy_ratio = sum(copy_ratios) / len(copy_ratios) if copy_ratios else 1.0
    
        total_pnl = sum(t['pnl'] for t in copy_trades)
    
        return {
            'total_copy_trades': total_trades,
            'copy_win_rate': winning_trades / total_trades,
            'avg_copy_ratio': avg_copy_ratio,
            'total_copy_pnl': total_pnl,
            'copy_profit_factor': self._calculate_profit_factor(copy_trades)
        }

    def _calculate_profit_factor(self, trades: List[Dict]) -> float:
        """–†–∞—Å—á–µ—Ç Profit Factor –¥–ª—è –∫–æ–ø–∏-—Å–¥–µ–ª–æ–∫"""
        wins = [t['pnl'] for t in trades if t['pnl'] > 0]
        losses = [abs(t['pnl']) for t in trades if t['pnl'] < 0]
    
        total_wins = sum(wins) if wins else 0
        total_losses = sum(losses) if losses else 1  # –ò–∑–±–µ–≥–∞–µ–º –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
    
        return total_wins / total_losses if total_losses > 0 else float('inf')

# ================================
# TRAILING STOP-LOSS SYSTEM
# ================================

class DynamicTrailingStopManager:
    """
    –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö Trailing Stop-Loss
    
    –û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞:
    - ATR (Average True Range) –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
    - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
    - –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å—Ç–∏–ª–∏ —Ç—Ä–µ–π–ª–∏–Ω–≥–∞
    """
    
    def __init__(self):
        self.active_stops = {}  # symbol -> TrailingStop
        self.price_history = defaultdict(lambda: deque(maxlen=50))
        self.atr_cache = {}
        self.last_update = defaultdict(float)
        
    def reload_config(self, cfg: dict) -> None:
        """
        –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Trailing Stop –≤ —Ä–∞–Ω—Ç–∞–π–º–µ.
    
        Args:
            cfg: –°–ª–æ–≤–∞—Ä—å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ trailing (–∏–∑ TRAILING_CONFIG)
        """
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
            old_config = {
                'atr_period': self.atr_period,
                'atr_multiplier_conservative': self.atr_multiplier_conservative,
                'atr_multiplier_moderate': self.atr_multiplier_moderate,
                'atr_multiplier_aggressive': self.atr_multiplier_aggressive,
                'min_trail_distance': self.min_trail_distance,
                'max_trail_distance': self.max_trail_distance,
                'update_threshold': self.update_threshold
            }
        
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ATR
            self.atr_period = int(cfg.get('atr_period', 14))
            self.atr_multiplier_conservative = float(cfg.get('atr_multiplier_conservative', 2.0))
            self.atr_multiplier_moderate = float(cfg.get('atr_multiplier_moderate', 1.5))
            self.atr_multiplier_aggressive = float(cfg.get('atr_multiplier_aggressive', 1.0))
        
            # –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–º–∏—Ç—ã
            self.min_trail_distance = float(cfg.get('min_trail_distance', 0.005))
            self.max_trail_distance = float(cfg.get('max_trail_distance', 0.05))
            self.update_threshold = float(cfg.get('update_threshold', 0.001))
        
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à ATR –¥–ª—è –ø–µ—Ä–µ—Å—á—ë—Ç–∞ —Å –Ω–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
            cache_size_before = len(self.atr_cache)
            self.atr_cache.clear()
        
            # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
            sys_logger.log_event(
                "INFO",
                "TrailingStopManager",
                "Trailing stop configuration updated",
                {
                    "old_config": old_config,
                    "new_config": {
                        'atr_period': self.atr_period,
                        'atr_multiplier_conservative': self.atr_multiplier_conservative,
                        'atr_multiplier_moderate': self.atr_multiplier_moderate,
                        'atr_multiplier_aggressive': self.atr_multiplier_aggressive,
                        'min_trail_distance': self.min_trail_distance,
                        'max_trail_distance': self.max_trail_distance,
                        'update_threshold': self.update_threshold
                    },
                    "active_stops_count": len(self.trailing_stops),
                    "atr_cache_cleared": cache_size_before
                }
            )
        
            logger.info(f"Trailing config reloaded: ATR period={self.atr_period}")
        
        except Exception as e:
            sys_logger.log_error(
                "TrailingStopManager",
                f"Config reload failed: {str(e)}",
                {"config": cfg, "error": str(e)}
            )
            logger.error(f"Failed to reload trailing config: {e}")
            raise

    def calculate_atr(self, symbol: str, price_data: List[Dict[str, float]], period: int = None) -> float:
        """
        –†–∞—Å—á–µ—Ç Average True Range (ATR)
        
        ATR = SMA(TR, period)
        –≥–¥–µ TR = max(H-L, |H-C_prev|, |L-C_prev|)
        """
        try:
            if period is None:
                period = TRAILING_CONFIG['atr_period']
                
            if len(price_data) < period:
                return 0.01  # –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            
            true_ranges = []
            
            for i in range(1, len(price_data)):
                high = price_data[i]['high']
                low = price_data[i]['low']
                prev_close = price_data[i-1]['close']
                
                tr1 = high - low
                tr2 = abs(high - prev_close)
                tr3 = abs(low - prev_close)
                
                true_range = max(tr1, tr2, tr3)
                true_ranges.append(true_range)
            
            if len(true_ranges) >= period:
                atr = np.mean(true_ranges[-period:])
                
                # –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                self.atr_cache[symbol] = {
                    'value': atr,
                    'timestamp': time.time()
                }
                
                return atr
            
            return 0.01
            
        except Exception as e:
            logger.error(f"ATR calculation error for {symbol}: {e}")
            return 0.01
    
    def determine_trailing_style(self, market_conditions: MarketConditions) -> TrailingStyle:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç–∏–ª—è —Ç—Ä–µ–π–ª–∏–Ω–≥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π"""
        try:
            volatility = market_conditions.volatility
            trend_strength = market_conditions.trend_strength
            volume_ratio = market_conditions.volume_ratio
            liquidity_score = market_conditions.liquidity_score
            
            # –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å = –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π —Ç—Ä–µ–π–ª–∏–Ω–≥
            if volatility > 0.03:
                return TrailingStyle.CONSERVATIVE
            
            # –°–∏–ª—å–Ω—ã–π —Ç—Ä–µ–Ω–¥ + –≤—ã—Å–æ–∫–∏–π –æ–±—ä–µ–º = –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π —Ç—Ä–µ–π–ª–∏–Ω–≥
            if trend_strength > 0.7 and volume_ratio > 1.5:
                return TrailingStyle.AGGRESSIVE
            
            # –ù–∏–∑–∫–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å = –∫–æ–Ω—Å–µ—Ä–≤–∞—Ç–∏–≤–Ω—ã–π —Ç—Ä–µ–π–ª–∏–Ω–≥
            if liquidity_score < 0.5:
                return TrailingStyle.CONSERVATIVE
            
            # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —É–º–µ—Ä–µ–Ω–Ω—ã–π
            return TrailingStyle.MODERATE
            
        except Exception as e:
            logger.error(f"Error determining trailing style: {e}")
            return TrailingStyle.MODERATE
    
    def create_trailing_stop(self, symbol: str, side: str, current_price: float, 
                             position_size: float, market_conditions: MarketConditions = None) -> TrailingStop:
        """
        –°–æ–∑–¥–∞–Ω–∏–µ trailing stop —Å –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ú —Ä–∞—Å—á–µ—Ç–æ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
        –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç —Ä–∞–∑—É–º–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–∞–∂–µ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ ATR –¥–∞–Ω–Ω—ã—Ö
        """
        try:
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∏–ª—å —Ç—Ä–µ–π–ª–∏–Ω–≥–∞
            if market_conditions:
                trail_style = self.determine_trailing_style(market_conditions)
                volatility = market_conditions.volatility
            else:
                trail_style = TrailingStyle.MODERATE
                volatility = 0.01
        
            # –ü–æ–ª—É—á–∞–µ–º ATR (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
            atr_value = 0.01
            if symbol in self.atr_cache:
                cache_data = self.atr_cache[symbol]
                if time.time() - cache_data['timestamp'] < 300:  # 5 –º–∏–Ω—É—Ç –∫—ç—à
                    atr_value = cache_data['value']
        
            # –í—ã–±–∏—Ä–∞–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∏–ª—è
            multiplier_map = {
                TrailingStyle.CONSERVATIVE: TRAILING_CONFIG.get('atr_multiplier_conservative', 2.0),
                TrailingStyle.MODERATE: TRAILING_CONFIG.get('atr_multiplier_moderate', 1.5),
                TrailingStyle.AGGRESSIVE: TRAILING_CONFIG.get('atr_multiplier_aggressive', 1.0)
            }
            multiplier = multiplier_map[trail_style]
        
            # ===== –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –†–ê–°–ß–ï–¢ –ë–ê–ó–û–í–û–ô –î–ò–°–¢–ê–ù–¶–ò–ò =====
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–¥–µ–∫–≤–∞—Ç–Ω–æ—Å—Ç—å ATR
            if atr_value < current_price * 0.001:  # ATR —Å–ª–∏—à–∫–æ–º –º–∞–ª (–º–µ–Ω–µ–µ 0.1% –æ—Ç —Ü–µ–Ω—ã)
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç —Ü–µ–Ω—ã –≤–º–µ—Å—Ç–æ ATR
                if trail_style == TrailingStyle.CONSERVATIVE:
                    base_distance = current_price * 0.02  # 2%
                elif trail_style == TrailingStyle.MODERATE:
                    base_distance = current_price * 0.01  # 1%
                else:  # AGGRESSIVE
                    base_distance = current_price * 0.015  # 1.5%
            
                logger.warning(f"ATR too small for {symbol} ({atr_value:.6f}), using percentage-based distance")
            else:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º ATR-based —Ä–∞—Å—á–µ—Ç
                base_distance = atr_value * multiplier
            
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–∑—É–º–Ω–æ—Å—Ç—å
                min_reasonable = current_price * 0.005  # –ú–∏–Ω–∏–º—É–º 0.5%
                max_reasonable = current_price * 0.03   # –ú–∞–∫—Å–∏–º—É–º 3%
            
                if base_distance < min_reasonable:
                    logger.warning(f"ATR distance too small for {symbol}, adjusting to minimum")
                    base_distance = min_reasonable
                elif base_distance > max_reasonable:
                    logger.warning(f"ATR distance too large for {symbol}, adjusting to maximum")
                    base_distance = max_reasonable
        
            # –ê–¥–∞–ø—Ç–∞—Ü–∏—è –∫ —Ä–∞–∑–º–µ—Ä—É –ø–æ–∑–∏—Ü–∏–∏ (–±–æ–ª—å—à–µ –ø–æ–∑–∏—Ü–∏—è = –±–æ–ª—å—à–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏—è)
            position_factor = min(2.0, max(1.0, (position_size / 1000) * 0.1))
            adjusted_distance = base_distance * position_factor
        
            # –§–∏–Ω–∞–ª—å–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
            min_distance = current_price * TRAILING_CONFIG.get('min_trail_distance', 0.005)
            max_distance = current_price * TRAILING_CONFIG.get('max_trail_distance', 0.05)
            final_distance = max(min_distance, min(max_distance, adjusted_distance))
        
            # –†–∞—Å—á–µ—Ç —Å—Ç–æ–ø-—Ü–µ–Ω—ã (–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è Buy/Sell)
            if side.upper() == 'BUY':
                stop_price = current_price - final_distance  # –î–ª—è –ª–æ–Ω–≥–∞ —Å—Ç–æ–ø –ù–ò–ñ–ï
            else:
                stop_price = current_price + final_distance  # –î–ª—è —à–æ—Ä—Ç–∞ —Å—Ç–æ–ø –í–´–®–ï
        
            # –†–∞—Å—á–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
            distance_percent = final_distance / current_price  # –í –¥–æ–ª—è—Ö (0.01 = 1%)
        
            # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç TrailingStop
            trailing_stop = TrailingStop(
                symbol=symbol,
                side=side,
                current_price=current_price,
                stop_price=stop_price,
                distance=final_distance,
                distance_percent=distance_percent,
                trail_style=trail_style,
                atr_value=atr_value
            )
        
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç–æ–ø—ã (–ø—Ä–æ–≤–µ—Ä—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã)
            if symbol not in self.active_stops:
                self.active_stops[symbol] = trailing_stop
                logger.info(f"Created trailing stop for {symbol} {side}: "
                           f"style={trail_style.value}, "
                           f"distance=${final_distance:.2f} ({distance_percent:.1%}), "
                           f"stop=${stop_price:.2f}, current=${current_price:.2f}")
            else:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π
                existing = self.active_stops[symbol]
                existing.current_price = current_price
                existing.stop_price = stop_price
                existing.distance = final_distance
                existing.distance_percent = distance_percent
                trailing_stop = existing
                logger.debug(f"Updated existing trailing stop for {symbol}")
        
            return trailing_stop
        
        except Exception as e:
            logger.error(f"Error creating trailing stop for {symbol}: {e}")
        
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π trailing stop
            safe_distance = current_price * 0.015  # 1.5% –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
            return TrailingStop(
                symbol=symbol,
                side=side,
                current_price=current_price,
                stop_price=current_price - safe_distance if side.upper() == 'BUY' else current_price + safe_distance,
                distance=safe_distance,
                distance_percent=0.015,  # 1.5%
                trail_style=TrailingStyle.MODERATE,
                atr_value=0.0
            )
    
    def update_trailing_stop(self, symbol: str, new_price: float) -> Optional[TrailingStop]:
        """
        –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ trailing stop —Å –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ–º –ü–†–û–¶–ï–ù–¢–ù–û–ô –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
        + –∑–∞—â–∏—Ç–∞ –æ—Ç —à—É–º–æ–≤—ã—Ö –º–∏–∫—Ä–æ—Å–¥–≤–∏–≥–æ–≤ (–æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∏ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø–æ—Ä–æ–≥–∏).
        """
        try:
            if symbol not in self.active_stops:
                return None

            stop = self.active_stops[symbol]

            # 1) –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ (–≤ –¥–æ–ª—è—Ö)
            rel_change = abs(new_price - stop.current_price) / max(1e-12, stop.current_price)
            if rel_change < TRAILING_CONFIG.get('update_threshold', 0.001):
                return stop  # —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ

            # 2) –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø–æ—Ä–æ–≥ (–≤ –¥–æ–ª–ª–∞—Ä–∞—Ö)
            min_abs = TRAILING_CONFIG.get('min_abs_move', 0.0)
            if min_abs and abs(new_price - stop.current_price) < min_abs:
                return stop  # —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ

            should_update  = False
            new_stop_price = stop.stop_price

            if stop.side.upper() == 'BUY':
                # –¥–ª—è –ª–æ–Ω–≥–∞ —Å—Ç–æ–ø —Ç–æ–ª—å–∫–æ –≤–≤–µ—Ä—Ö
                if new_price > stop.current_price:
                    new_stop_price = new_price * (1 - stop.distance_percent)
                    should_update = new_stop_price > stop.stop_price
            else:
                # –¥–ª—è —à–æ—Ä—Ç–∞ —Å—Ç–æ–ø —Ç–æ–ª—å–∫–æ –≤–Ω–∏–∑
                if new_price < stop.current_price:
                    new_stop_price = new_price * (1 + stop.distance_percent)
                    should_update = new_stop_price < stop.stop_price

            if not should_update:
                return stop

            old_stop          = stop.stop_price
            old_distance_pct  = stop.distance_percent
            stop.stop_price   = new_stop_price
            stop.current_price= new_price
            stop.distance     = abs(new_price - new_stop_price)  # –ø–µ—Ä–µ—Å—á—ë—Ç –∞–±—Å–æ–ª—é—Ç–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
            stop.last_update  = time.time()

            logger.info(
                f"Updated trailing stop for {symbol}: ${old_stop:.2f} -> ${new_stop_price:.2f} "
                f"(maintaining {old_distance_pct:.1%} distance)"
            )
            return stop

        except Exception as e:
            logger.error(f"Trailing stop update error: {e}")
            return None

    
    def check_stop_triggered(self, symbol: str, current_price: float) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è trailing stop - –ü–û–õ–ù–ê–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        try:
            if symbol not in self.active_stops:
                return False
        
            stop = self.active_stops[symbol]
    
            # –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è –ª–æ–Ω–≥–æ–≤ –∏ —à–æ—Ä—Ç–æ–≤
            if stop.side.upper() == 'BUY':
                # –î–ª—è –õ–û–ù–ì–û–í: —Å—Ç–æ–ø —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–≥–¥–∞ —Ü–µ–Ω–∞ –ü–ê–î–ê–ï–¢ –ù–ò–ñ–ï —Å—Ç–æ–ø-—Ü–µ–Ω—ã
                triggered = current_price <= stop.stop_price
                if triggered:
                    # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                    risk_events_logger.log_risk_event(
                        account_id=2,
                        event=RiskEventType.TRAILING_STOP_HIT,
                        reason=f"{symbol} LONG: Price ${current_price:.2f} hit stop ${stop.stop_price:.2f}",
                        value=float(stop.stop_price)
                    )
                
                    logger.warning(f"üìâ Trailing stop TRIGGERED for LONG {symbol}: "
                                 f"current_price={current_price:.2f} <= stop={stop.stop_price:.2f}")
            else:
                # –î–ª—è –®–û–†–¢–û–í: —Å—Ç–æ–ø —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–≥–¥–∞ —Ü–µ–Ω–∞ –ü–û–î–ù–ò–ú–ê–ï–¢–°–Ø –í–´–®–ï —Å—Ç–æ–ø-—Ü–µ–Ω—ã
                triggered = current_price >= stop.stop_price
                if triggered:
                    # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                    risk_events_logger.log_risk_event(
                        account_id=2,
                        event=RiskEventType.TRAILING_STOP_HIT,
                        reason=f"{symbol} SHORT: Price ${current_price:.2f} hit stop ${stop.stop_price:.2f}",
                        value=float(stop.stop_price)
                    )
                
                    logger.warning(f"üìà Trailing stop TRIGGERED for SHORT {symbol}: "
                                 f"current_price={current_price:.2f} >= stop={stop.stop_price:.2f}")
    
            return triggered
    
        except Exception as e:
            logger.error(f"Error checking trailing stop for {symbol}: {e}")
            return False

# ================================================
# –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ú–ï–¢–û–î execute_trailing_stop
# ================================================

    async def execute_trailing_stop(self, symbol: str, stop: Any) -> bool:
        """
        –ò–°–ü–†–ê–í–õ–ï–ù–ù–û–ï –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ trailing stop
        """
        try:
            logger.info(f"üõë Executing trailing stop for {symbol}")
        
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞–ø—Ä—è–º—É—é —Å –±–∏—Ä–∂–∏
            positions = None
            if hasattr(self, 'copy_manager') and hasattr(self.copy_manager, 'main_client'):
                positions = await self.copy_manager.main_client.get_positions()
            elif hasattr(self, 'base_monitor') and hasattr(self.base_monitor, 'main_client'):
                positions = await self.base_monitor.main_client.get_positions()
        
            if not positions:
                logger.error("Cannot get positions from exchange")
                return False
        
            # –ù–∞—Ö–æ–¥–∏–º –Ω—É–∂–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
            position_data = None
            for pos in positions:
                if pos.get('symbol') == symbol:
                    size = safe_float(pos.get('size', 0))
                    if size > 0:
                        position_data = pos
                        break
        
            if not position_data:
                logger.warning(f"No open position found for {symbol}, removing trailing stop")
                if hasattr(self, 'active_stops') and symbol in self.active_stops:
                    del self.active_stops[symbol]
                return True  # –ü–æ–∑–∏—Ü–∏—è —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞
        
            # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∑–∏—Ü–∏–∏
            position_size = safe_float(position_data.get('size', 0))
            position_side = position_data.get('side', 'Buy')
        
            if position_size <= 0:
                logger.error(f"Invalid position size: {position_size}")
                return False
        
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–æ—Ä–æ–Ω—É –∑–∞–∫—Ä—ã—Ç–∏—è
            close_side = 'Sell' if position_side == 'Buy' else 'Buy'
        
            logger.info(f"Closing position: {symbol} {close_side} size={position_size:.6f}")
        
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞ –¥–ª—è Bybit
            order_data = {
                "category": "linear",
                "symbol": symbol,
                "side": close_side,
                "orderType": "Market",
                "qty": str(position_size),
                "timeInForce": "IOC",
                "reduceOnly": True,
                "closeOnTrigger": False
            }
        
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä
            client = None
            if hasattr(self, 'copy_manager') and hasattr(self.copy_manager, 'main_client'):
                client = self.copy_manager.main_client
            elif hasattr(self, 'base_monitor') and hasattr(self.base_monitor, 'main_client'):
                client = self.base_monitor.main_client
        
            if not client:
                logger.error("No client available for order placement")
                return False
        
            result = await client._make_request_with_retry("POST", "order/create", data=order_data)
        
            if result and result.get('retCode') == 0:
                order_id = result['result'].get('orderId')
                logger.info(f"‚úÖ Trailing stop order placed: {order_id}")
            
                # –£–¥–∞–ª—è–µ–º trailing stop
                if hasattr(self, 'active_stops') and symbol in self.active_stops:
                    del self.active_stops[symbol]
            
                # –û—á–∏—â–∞–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
                if hasattr(self, 'copy_manager') and hasattr(self.copy_manager, 'active_positions'):
                    if symbol in self.copy_manager.active_positions:
                        del self.copy_manager.active_positions[symbol]
            
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                await send_telegram_alert(
                    f"üõë **TRAILING STOP EXECUTED**\n"
                    f"Symbol: {symbol}\n"
                    f"Size: {position_size:.6f}\n"
                    f"Stop: ${stop.stop_price:.2f}\n"
                    f"Order: {order_id}"
                )
            
                return True
            else:
                error_msg = result.get('retMsg', 'Unknown') if result else 'No response'
                logger.error(f"Order failed: {error_msg}")
            
                # –ï—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞
                if 'reduce only' in error_msg.lower():
                    if hasattr(self, 'active_stops') and symbol in self.active_stops:
                        del self.active_stops[symbol]
                    return True
            
                return False
            
        except Exception as e:
            logger.error(f"Trailing stop execution error: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    def remove_trailing_stop(self, symbol: str):
        """–£–¥–∞–ª–µ–Ω–∏–µ trailing stop"""
        if symbol in self.active_stops:
            del self.active_stops[symbol]
            logger.info(f"Removed trailing stop for {symbol}")
    
    def get_all_stops(self) -> Dict[str, TrailingStop]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö trailing stops"""
        return self.active_stops.copy()

# ================================
# –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–ï–ù–ò–Ø –û–†–î–ï–†–ê–ú–ò
# ================================

class AdaptiveOrderManager:
    """
    –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞–º–∏
    
    –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:
    - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≤—ã–±–æ—Ä —Ç–∏–ø–∞ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
    - –ó–∞—â–∏—Ç–∞ –æ—Ç –ø—Ä–æ—Å–∫–∞–ª—å–∑—ã–≤–∞–Ω–∏—è
    - Retry –º–µ—Ö–∞–Ω–∏–∑–º —Å exponential backoff
    - –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
    """
    
    def __init__(self, main_client: EnhancedBybitClient, order_formatter=None, risk_manager=None, logger=None):
        import logging

        # –∫–ª–∏–µ–Ω—Ç—ã/–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        self.main_client = main_client
        # —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å, –µ—Å–ª–∏ –≥–¥–µ‚Äë—Ç–æ –æ–±—Ä–∞—â–∞—é—Ç—Å—è –∫–∞–∫ self.client
        self.client = main_client
        self.order_formatter = order_formatter
        self.risk_manager = risk_manager

        # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–æ–≥–≥–µ—Ä–∞ (–∏ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π –∞–ª–∏–∞—Å self.log)
        self.logger = logger or logging.getLogger("AdaptiveOrderManager")
        self.log = self.logger

        # –æ—á–µ—Ä–µ–¥–∏/—Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∫–∞–∫ –≤ –≤–∞—à–µ–π –≤–µ—Ä—Å–∏–∏
        self.order_queue = asyncio.PriorityQueue()
        self.pending_orders = {}
        self.order_history = deque(maxlen=1000)
        self.execution_stats = defaultdict(lambda: {'success': 0, 'failed': 0, 'avg_time': 0})

        
    async def get_market_analysis(self, symbol: str) -> MarketConditions:
        """–ê–Ω–∞–ª–∏–∑ —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å—Ç–∞–∫–∞–Ω–µ
            orderbook_params = {
                "category": "linear",
                "symbol": symbol,
                "limit": 50
            }
            
            orderbook_result = await self.main_client._make_request_with_retry(
                "GET", "market/orderbook", orderbook_params
            )
            
            # –ü–æ–ª—É—á–∞–µ–º —Ç–∏–∫–µ—Ä –¥–∞–Ω–Ω—ã–µ
            ticker_params = {
                "category": "linear", 
                "symbol": symbol
            }
            
            ticker_result = await self.main_client._make_request_with_retry(
                "GET", "market/tickers", ticker_params
            )
            
            if not orderbook_result or not ticker_result:
                return self._default_market_conditions()
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—Ç–∞–∫–∞–Ω
            orderbook_data = orderbook_result.get('result', {})
            bids = orderbook_data.get('b', [])
            asks = orderbook_data.get('a', [])
            
            if not bids or not asks:
                return self._default_market_conditions()
            
            best_bid = safe_float(bids[0][0])
            best_ask = safe_float(asks[0][0])
            spread = best_ask - best_bid
            spread_percent = (spread / best_ask) * 100 if best_ask > 0 else 0
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å
            bid_volume = sum(safe_float(bid[1]) for bid in bids[:10])
            ask_volume = sum(safe_float(ask[1]) for ask in asks[:10])
            total_volume = bid_volume + ask_volume
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∏–∫–µ—Ä
            ticker_data = ticker_result.get('result', {}).get('list', [])
            if ticker_data:
                ticker = ticker_data[0]
                volume_24h = safe_float(ticker.get('volume24h', 0))
                turnover_24h = safe_float(ticker.get('turnover24h', 0))
                price_change_24h = safe_float(ticker.get('price24hPcnt', 0))
            else:
                volume_24h = 0
                turnover_24h = 0
                price_change_24h = 0
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
            volatility = abs(price_change_24h)
            volume_ratio = min(2.0, volume_24h / 1000000) if volume_24h > 0 else 0.1
            trend_strength = min(1.0, abs(price_change_24h) / 5.0)  # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ 5%
            liquidity_score = min(1.0, total_volume / 1000) if total_volume > 0 else 0.1
            
            return MarketConditions(
                volatility=volatility,
                spread_percent=spread_percent, 
                volume_ratio=volume_ratio,
                trend_strength=trend_strength,
                liquidity_score=liquidity_score
            )
            
        except Exception as e:
            logger.error(f"Market analysis error for {symbol}: {e}")
            return self._default_market_conditions()
    
    def _default_market_conditions(self) -> MarketConditions:
        """–î–µ—Ñ–æ–ª—Ç–Ω—ã–µ —Ä—ã–Ω–æ—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –ø—Ä–∏ –æ—à–∏–±–∫–µ –∞–Ω–∞–ª–∏–∑–∞"""
        return MarketConditions(
            volatility=0.02,
            spread_percent=0.1,
            volume_ratio=1.0,
            trend_strength=0.5,
            liquidity_score=0.8
        )
    
    def select_order_strategy(self, market_conditions: MarketConditions, 
                            urgency: str = 'normal') -> OrderStrategy:
        """–í—ã–±–æ—Ä –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ—Ä–¥–µ—Ä–∞"""
        try:
            spread_pct = market_conditions.spread_percent
            volume_ratio = market_conditions.volume_ratio
            volatility = market_conditions.volatility
            liquidity = market_conditions.liquidity_score
            
            # –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏–ª–∏ —É–∑–∫–∏–π —Å–ø—Ä–µ–¥ = Market –æ—Ä–¥–µ—Ä
            if urgency == 'high' or spread_pct < 0.05:
                return OrderStrategy.MARKET
            
            # –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å = Aggressive Limit
            if volatility > 0.02:
                return OrderStrategy.AGGRESSIVE_LIMIT
            
            # –ù–∏–∑–∫–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å = –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã–π Limit
            if liquidity < 0.5 or volume_ratio < 0.3:
                return OrderStrategy.LIMIT
            
            # –ù–æ—Ä–º–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è = Adaptive
            return OrderStrategy.ADAPTIVE
            
        except Exception as e:
            logger.error(f"Order strategy selection error: {e}")
            return OrderStrategy.MARKET
    
    async def place_adaptive_order(self, copy_order: CopyOrder) -> Dict[str, Any]:
        """–†–∞–∑–º–µ—â–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞"""
        try:
            start_time = time.time()
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä—ã–Ω–æ–∫
            market_conditions = await self.get_market_analysis(copy_order.target_symbol)
            
            # –í—ã–±–∏—Ä–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–∞
            if copy_order.order_strategy == OrderStrategy.ADAPTIVE:
                urgency = 'high' if copy_order.priority >= 3 else 'normal'
                copy_order.order_strategy = self.select_order_strategy(market_conditions, urgency)
            
            # –†–∞–∑–º–µ—â–∞–µ–º –æ—Ä–¥–µ—Ä —Å–æ–≥–ª–∞—Å–Ω–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            if copy_order.order_strategy == OrderStrategy.MARKET:
                result = await self._place_market_order(copy_order)
            elif copy_order.order_strategy == OrderStrategy.LIMIT:
                result = await self._place_smart_limit_order(copy_order, market_conditions)
            elif copy_order.order_strategy == OrderStrategy.AGGRESSIVE_LIMIT:
                result = await self._place_aggressive_limit_order(copy_order, market_conditions)
            else:
                result = await self._place_market_order(copy_order)  # Fallback
            
            # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            execution_time = time.time() - start_time
            self._update_execution_stats(copy_order.target_symbol, True, execution_time)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
            self.order_history.append({
                'copy_order': copy_order,
                'result': result,
                'execution_time': execution_time,
                'market_conditions': market_conditions,
                'timestamp': time.time()
            })
            
            return result
            
        except Exception as e:
            logger.error(f"Adaptive order placement error: {e}")
            self._update_execution_stats(copy_order.target_symbol, False, 0)
            return {'success': False, 'error': str(e)}
    
    async def _normalize_price_to_tick(self, symbol: str, raw_price: float, side: str | None = None) -> str:
        """
        –ü—Ä–∏–≤–æ–¥–∏–º —Ü–µ–Ω—É –∫ –±–∏—Ä–∂–µ–≤–æ–º—É tickSize.
        –î–ª—è buy ‚Äì –æ–±—ã—á–Ω–æ –æ–∫—Ä—É–≥–ª—è–µ–º –í–í–ï–†–• (—á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–º–∞—Ö–Ω—É—Ç—å—Å—è),
        –¥–ª—è sell ‚Äì –í–ù–ò–ó. –ï—Å–ª–∏ side –Ω–µ –∑–∞–¥–∞–Ω ‚Äì –æ–±—ã—á–Ω—ã–π round –∫ –±–ª–∏–∂–∞–π—à–µ–º—É —Ç–∏–∫—É.
        –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç—Ä–æ–∫—É —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —á–∏—Å–ª–æ–º –∑–Ω–∞–∫–æ–≤.
        """
        try:
            f = await self.main_client.get_symbol_filters(symbol, category="linear")
            tick = float(f.get("tick_size") or 0.01)

            # –æ–ø—Ä–µ–¥–µ–ª–∏–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é —Ç–æ—á–Ω–æ—Å—Ç—å –ø–æ tick
            dec = 0
            if tick < 1:
                s = f"{tick:.12f}".rstrip('0')
                dec = len(s.split('.')[-1]) if '.' in s else 0

            if tick <= 0:
                return f"{raw_price:.{dec}f}"

            q = raw_price / tick
            if side and side.lower() == "buy":
                snapped = math.ceil(q) * tick
            elif side and side.lower() == "sell":
                snapped = math.floor(q) * tick
            else:
                snapped = round(q) * tick

            return f"{snapped:.{dec}f}"
        except Exception as e:
            logger.warning(f"_normalize_price_to_tick fallback: {e}")
            return f"{raw_price:.2f}"

    async def _format_qty_live(self, symbol: str, quantity: float, price: float | None) -> str:
        """
        –û–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ format_quantity_for_symbol_live, —á—Ç–æ–±—ã –Ω–µ —Ç—è–Ω—É—Ç—å –∏–º–ø–æ—Ä—Ç —É—Ç–∏–ª–∏—Ç—ã –≤ –∫–∞–∂–¥–æ–º –º–µ—Å—Ç–µ.
        """
        try:
            return await format_quantity_for_symbol_live(self.main_client, symbol, quantity, price)
        except Exception as e:
            logger.warning(f"_format_qty_live fallback: {e}")
            return format_quantity_for_symbol(symbol, quantity, price)

    async def _place_market_order(self, copy_order: CopyOrder) -> Dict[str, Any]:
        """
        –†–∞–∑–º–µ—â–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞ (v5) —Å orderLinkId –∏ live‚Äë—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞.
        –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã –ø–æ —É—á—ë—Ç—É —É—Å–ø–µ—à–Ω–æ–π —Å–¥–µ–ª–∫–∏ ‚Äî retCode == 0.
        """
        try:
            # 1) –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞
            current_price = copy_order.target_price
            if not current_price or current_price <= 0:
                params = {"category": "linear", "symbol": copy_order.target_symbol}
                tickers = await self.main_client._make_request_with_retry("GET", "market/tickers", params)
                if tickers and tickers.get("retCode") == 0:
                    lst = tickers.get("result", {}).get("list", [])
                    if lst:
                        current_price = float(lst[0].get("lastPrice") or 0.0)

            if not current_price or current_price <= 0:
                raise RuntimeError("Unable to obtain current price for market order")

            # 2) –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å —É—á—ë—Ç–æ–º —Ä–µ–∞–ª—å–Ω—ã—Ö —Ñ–∏–ª—å—Ç—Ä–æ–≤ (stepSize, minQty, minNotional)
            formatted_qty = await format_quantity_for_symbol_live(
                self.main_client, copy_order.target_symbol, copy_order.target_quantity, current_price
            )

            # –ü–æ–¥—Å—Ç—Ä–∞—Ö—É–µ–º min notional (—á–∞—Å—Ç—å –±–∏—Ä–∂ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–µ—Ä–µ–∑ instruments-info; —Ñ–æ—Ä–º–∞—Ç–µ—Ä —ç—Ç–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç,
            # –Ω–æ –æ—Å—Ç–∞–≤–∏–º safety‚Äëcheck –Ω–∞ $5 –∫–∞–∫ —Ä–∞–∑—É–º–Ω—ã–π –Ω–∏–∂–Ω–∏–π –ø–æ—Ä–æ–≥)
            order_value = float(formatted_qty) * float(current_price)
            if order_value < 5.0:
                min_qty = 5.0 / float(current_price)
                formatted_qty = await format_quantity_for_symbol_live(
                    self.main_client, copy_order.target_symbol, min_qty, current_price
                )
                order_value = float(formatted_qty) * float(current_price)

            # 3) –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å –Ω–∞ —É—Ä–æ–≤–Ω–µ –æ—Ä–¥–µ—Ä–∞
            link_id = f"copy:{copy_order.target_symbol}:{int(time.time()*1000)}:{uuid.uuid4().hex[:8]}"

            order_data = {
                "category": "linear",
                "symbol": copy_order.target_symbol,
                "side": copy_order.target_side,          # 'Buy' / 'Sell'
                "orderType": "Market",
                "qty": formatted_qty,                     # —Å—Ç—Ä–æ–∫–∞, –∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç v5
                "timeInForce": "IOC",
                "orderLinkId": link_id
            }

            self.logger.info(
                f"Placing MARKET: {copy_order.target_symbol} {copy_order.target_side} "
                f"qty={formatted_qty} value=${order_value:.2f}"
            )

            result = await self.main_client._make_request_with_retry("POST", "order/create", data=order_data)

            if result and result.get("retCode") == 0:
                order_id = result.get("result", {}).get("orderId")
                self.logger.info(f"Market order placed successfully: {order_id} link={link_id}")
                return {
                    "success": True,
                    "order_id": order_id,
                    "order_link_id": link_id,
                    "type": "market",
                    "qty": formatted_qty,
                    "price": current_price
                }

            err = (result or {}).get("retMsg") or "No response"
            self.logger.error(f"Market order failed: {err}")
            if "Qty invalid" in err:
                self.logger.error(
                    f"Qty details: formatted={formatted_qty}, value=${float(formatted_qty) * float(current_price):.2f}, "
                    f"price=${float(current_price):.2f}"
                )
            return {"success": False, "error": err}

        except Exception as e:
            self.logger.exception(f"Market order error: {e}")
            return {"success": False, "error": str(e)}


    async def _place_smart_limit_order(self, copy_order: CopyOrder, market_conditions: MarketConditions) -> Dict[str, Any]:
        """
        –£–º–Ω—ã–π –ª–∏–º–∏—Ç —Å —É—á—ë—Ç–æ–º –ª—É—á—à–µ–≥–æ bid/ask –∏ orderLinkId.
        –¶–µ–Ω–∞ –æ–∫—Ä—É–≥–ª—è–µ—Ç—Å—è –¥–æ –¥–≤—É—Ö –∑–Ω–∞–∫–æ–≤ ‚Äî –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –¥–æ tickSize.
        """
        try:
            params = {"category": "linear", "symbol": copy_order.target_symbol}
            tickers = await self.main_client._make_request_with_retry("GET", "market/tickers", params)
            if not tickers or tickers.get("retCode") != 0:
                return await self._place_market_order(copy_order)

            lst = tickers.get("result", {}).get("list", [])
            if not lst:
                return await self._place_market_order(copy_order)

            t = lst[0]
            best_bid = float(t.get("bid1Price") or 0.0)
            best_ask = float(t.get("ask1Price") or 0.0)
            if best_bid <= 0 or best_ask <= 0:
                return await self._place_market_order(copy_order)

            spread = best_ask - best_bid
            if copy_order.target_side.lower() == "buy":
                limit_price = best_bid + spread * 0.30
            else:
                limit_price = best_ask - spread * 0.30

            formatted_qty = await format_quantity_for_symbol_live(
                self.main_client, copy_order.target_symbol, copy_order.target_quantity, limit_price
            )

            link_id = f"copy:{copy_order.target_symbol}:{int(time.time()*1000)}:{uuid.uuid4().hex[:8]}"

            order_data = {
                "category": "linear",
                "symbol": copy_order.target_symbol,
                "side": copy_order.target_side,
                "orderType": "Limit",
                "qty": formatted_qty,
                "price": f"{limit_price:.2f}",     # –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –º–æ–∂–Ω–æ –æ–∫—Ä—É–≥–ª—è—Ç—å –∫ tickSize (—Å–º. –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ –≤—ã—à–µ)
                "timeInForce": "GTC",
                "orderLinkId": link_id
            }

            result = await self.main_client._make_request_with_retry("POST", "order/create", data=order_data)
            if result and result.get("retCode") == 0:
                order_id = result.get("result", {}).get("orderId")
                self.logger.info(
                    f"Smart LIMIT placed: {copy_order.target_symbol} {copy_order.target_side} "
                    f"{formatted_qty} @ {limit_price:.2f} (ID: {order_id}, link={link_id})"
                )
                return {
                    "success": True,
                    "order_id": order_id,
                    "order_link_id": link_id,
                    "type": "smart_limit",
                    "price": limit_price,
                    "qty": formatted_qty
                }

            err = (result or {}).get("retMsg") or "No response"
            self.logger.error(f"Smart limit order failed: {err}")
            return {"success": False, "error": err}

        except Exception as e:
            self.logger.exception(f"Smart limit order error: {e}")
            return {"success": False, "error": str(e)}


    async def _place_aggressive_limit_order(self, copy_order: CopyOrder, market_conditions: MarketConditions) -> Dict[str, Any]:
        """
        –ê–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π –ª–∏–º–∏—Ç –ø–æ –ª—É—á—à–µ–π —Å—Ç–æ—Ä–æ–Ω–µ (IOC) —Å orderLinkId –∏ live‚Äë—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º qty.
        """
        try:
            params = {"category": "linear", "symbol": copy_order.target_symbol}
            tickers = await self.main_client._make_request_with_retry("GET", "market/tickers", params)
            if not tickers or tickers.get("retCode") != 0:
                return await self._place_market_order(copy_order)

            lst = tickers.get("result", {}).get("list", [])
            if not lst:
                return await self._place_market_order(copy_order)

            t = lst[0]
            best_bid = float(t.get("bid1Price") or 0.0)
            best_ask = float(t.get("ask1Price") or 0.0)
            if best_bid <= 0 or best_ask <= 0:
                return await self._place_market_order(copy_order)

            limit_price = best_ask if copy_order.target_side.lower() == "buy" else best_bid

            formatted_qty = await format_quantity_for_symbol_live(
                self.main_client, copy_order.target_symbol, copy_order.target_quantity, limit_price
            )

            link_id = f"copy:{copy_order.target_symbol}:{int(time.time()*1000)}:{uuid.uuid4().hex[:8]}"

            order_data = {
                "category": "linear",
                "symbol": copy_order.target_symbol,
                "side": copy_order.target_side,
                "orderType": "Limit",
                "qty": formatted_qty,
                "price": f"{limit_price:.2f}",
                "timeInForce": "IOC",
                "orderLinkId": link_id
            }

            result = await self.main_client._make_request_with_retry("POST", "order/create", data=order_data)
            if result and result.get("retCode") == 0:
                order_id = result.get("result", {}).get("orderId")
                self.logger.info(
                    f"Aggressive LIMIT placed: {copy_order.target_symbol} {copy_order.target_side} "
                    f"{formatted_qty} @ {limit_price:.2f} (ID: {order_id}, link={link_id})"
                )
                return {
                    "success": True,
                    "order_id": order_id,
                    "order_link_id": link_id,
                    "type": "aggressive_limit",
                    "price": limit_price,
                    "qty": formatted_qty
                }

            err = (result or {}).get("retMsg") or "No response"
            self.logger.error(f"Aggressive limit order failed: {err}")
            return {"success": False, "error": err}

        except Exception as e:
            self.logger.exception(f"Aggressive limit order error: {e}")
            return {"success": False, "error": str(e)}



    async def _monitor_order_execution(self, order_id: str, timeout: float = 30) -> Dict[str, Any]:
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞"""
        try:
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ä–¥–µ—Ä–∞
                order_params = {
                    "category": "linear",
                    "orderId": order_id
                }
                
                result = await self.main_client._make_request_with_retry(
                    "GET", "order/realtime", order_params
                )
                
                if result and result.get('retCode') == 0:
                    orders = result.get('result', {}).get('list', [])
                    if orders:
                        order = orders[0]
                        status = order.get('orderStatus')
                        
                        if status in ['Filled', 'PartiallyFilled']:
                            filled_qty = safe_float(order.get('cumExecQty', 0))
                            avg_price = safe_float(order.get('avgPrice', 0))
                            
                            return {
                                'status': status,
                                'filled_qty': filled_qty,
                                'avg_price': avg_price,
                                'execution_time': time.time() - start_time
                            }
                        elif status in ['Cancelled', 'Rejected']:
                            return {
                                'status': status,
                                'filled_qty': 0,
                                'execution_time': time.time() - start_time
                            }
                
                await asyncio.sleep(1)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
            
            # Timeout - –æ—Ç–º–µ–Ω—è–µ–º –æ—Ä–¥–µ—Ä
            await self._cancel_order(order_id)
            return {
                'status': 'Timeout',
                'filled_qty': 0,
                'execution_time': timeout
            }
            
        except Exception as e:
            logger.error(f"Order monitoring error: {e}")
            return {'status': 'Error', 'error': str(e)}
    
    async def _cancel_order(self, order_id: str) -> bool:
        """–û—Ç–º–µ–Ω–∞ –æ—Ä–¥–µ—Ä–∞"""
        try:
            cancel_data = {
                "category": "linear",
                "orderId": order_id
            }
            
            result = await self.main_client._make_request_with_retry("POST", "order/cancel", data=cancel_data)
            
            if result and result.get('retCode') == 0:
                logger.info(f"Order cancelled: {order_id}")
                return True
            else:
                logger.error(f"Order cancellation failed: {result}")
                return False
                
        except Exception as e:
            logger.error(f"Order cancellation error: {e}")
            return False
    
    def _update_execution_stats(self, symbol: str, success: bool, execution_time: float):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è"""
        try:
            stats = self.execution_stats[symbol]
            
            if success:
                stats['success'] += 1
                # –°–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º–µ–Ω–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
                if stats['avg_time'] == 0:
                    stats['avg_time'] = execution_time
                else:
                    stats['avg_time'] = stats['avg_time'] * 0.8 + execution_time * 0.2
            else:
                stats['failed'] += 1
                
        except Exception as e:
            logger.error(f"Stats update error: {e}")
    
    def get_execution_stats(self) -> Dict[str, Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è"""
        return dict(self.execution_stats)

# ================================
# –°–ò–°–¢–ï–ú–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –ü–û–ó–ò–¶–ò–ô
# ================================

class PositionCopyManager:
    """
    –û—Å–Ω–æ–≤–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π
    
    –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç:
    - Kelly Criterion –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–π
    - Adaptive Order Manager –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
    - Trailing Stop Manager –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏
    - Synchronization Manager –¥–ª—è –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞–¥–µ—Ä–∂–µ–∫
    """
    
    def __init__(self, source_client: EnhancedBybitClient, main_client: EnhancedBybitClient):
        self.source_client = source_client
        self.main_client = main_client
        
        # –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
        self.kelly_calculator = AdvancedKellyCalculator()
        self.order_manager = AdaptiveOrderManager(main_client)
        self.trailing_manager = DynamicTrailingStopManager()
        
        # –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
        self.copy_mode = CopyMode.KELLY_OPTIMAL
        self.active_positions = {}  # symbol -> position_data
        self.copy_queue = asyncio.PriorityQueue()
        self.position_mapping = {}  # source_id -> target_id
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.copy_stats = {
            'positions_copied': 0,
            'positions_closed': 0,
            'total_volume_copied': 0.0,
            'avg_sync_delay': 0.0,
            'copy_success_rate': 0.0,
            'kelly_adjustments': 0
        }
        
        # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏
        self.processing_active = False
        self._copy_processor_task = None
        self.should_stop = False

        #–ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞–¥–≤–æ–µ–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π –∏ –∑–∞–¥–≤–æ–µ–Ω–∏—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π
        self._copy_success_lock = asyncio.Lock()
        self._processed_link_ids: set[str] = set()

        self._recent_copy_window = 5  # —Å–µ–∫ ‚Äî –∞–Ω—Ç–∏–¥—É–±–ª—å –¥–ª—è force_copy –∏ —Ñ–æ–Ω–æ–≤–æ–≥–æ —Å–∫–∞–Ω–µ—Ä–∞
        self._recent_copies: dict[tuple[str, str], float] = {}  # (symbol, side) -> ts

        self._copy_success_lock = asyncio.Lock()
        self._processed_link_ids: set[str] = set()

    async def _mark_copy_success(self, order_link_id: str) -> bool:
        """
        –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞—è —Ñ–∏–∫—Å–∞—Ü–∏—è —É—Å–ø–µ—Ö–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É—á—Ç–µ–Ω–æ –≤–ø–µ—Ä–≤—ã–µ; False ‚Äî –µ—Å–ª–∏ —Ç–∞–∫–æ–π link —É–∂–µ —Å—á–∏—Ç–∞–ª—Å—è.
        """
        if not order_link_id:
            # –ø–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ ‚Äî –Ω–µ —Å—á–∏—Ç–∞–µ–º –ø—É—Å—Ç—ã–µ link_id
            return False
        async with self._copy_success_lock:
            if order_link_id in self._processed_link_ids:
                return False
            self._processed_link_ids.add(order_link_id)
            # –ï–î–ò–ù–°–¢–í–ï–ù–ù–û–ï –º–µ—Å—Ç–æ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞
            ##self.system_stats['successful_copies'] = self.system_stats.get('successful_copies', 0) + 1
            return True

    def _should_skip_duplicate(self, symbol: str, side: str) -> bool:
        """
        –ü—Ä–æ—Å—Ç–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–µ–π –ø—Ä–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–º –∑–∞–ø—É—Å–∫–µ (/force_copy + —Ñ–æ–Ω)
        –≤ —Ç–µ—á–µ–Ω–∏–µ _recent_copy_window —Å–µ–∫—É–Ω–¥ –ø–æ –æ–¥–Ω–æ–º—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É –∏ —Å—Ç–æ—Ä–æ–Ω–µ.
        """
        now = time.time()
        key = (symbol, side.lower())
        last = self._recent_copies.get(key, 0.0)
        if now - last < self._recent_copy_window:
            self.logger.warning(f"Skip duplicate copy within {self._recent_copy_window}s for {symbol} {side}")
            return True
        self._recent_copies[key] = now
        return False

        
    async def start_copying(self):
        """–ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        if not self.processing_active:
            if self._copy_processor_task and not self._copy_processor_task.done():
                self._copy_processor_task.cancel()
                
            self._copy_processor_task = asyncio.create_task(self._process_copy_queue())
            self.processing_active = True
            logger.info("Position copying system started")
    
    async def stop_copying(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        self.should_stop = True
        self.processing_active = False
        
        if self._copy_processor_task and not self._copy_processor_task.done():
            self._copy_processor_task.cancel()
            try:
                await asyncio.wait_for(self._copy_processor_task, timeout=5.0)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                pass
        
        logger.info("Position copying system stopped")
    
    
    
    
    async def _process_copy_queue(self):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—á–µ—Ä–µ–¥–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            while not self.should_stop:
                try:
                    # –ü–æ–ª—É—á–∞–µ–º –æ—Ä–¥–µ—Ä —Å –Ω–∞–∏–≤—ã—Å—à–∏–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
                    priority, timestamp, copy_order = await asyncio.wait_for(
                        self.copy_queue.get(), timeout=1.0
                    )
                    
                    # –í—ã–ø–æ–ª–Ω—è–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
                    await self._execute_copy_order(copy_order, timestamp)
                    
                    self.copy_queue.task_done()
                    
                except asyncio.TimeoutError:
                    continue  # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º should_stop
                except Exception as e:
                    logger.error(f"Copy queue processing error: {e}")
        except asyncio.CancelledError:
            logger.debug("Copy processor cancelled")
        except Exception as e:
            logger.error(f"Copy processor error: {e}")
    
    async def _account_success_once(self, result: dict, copy_order) -> bool:
        """
        –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞—è —Ñ–∏–∫—Å–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è.
        –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ç counters —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π orderLinkId/ orderId.
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —É—á—Ç–µ–Ω–æ –≤–ø–µ—Ä–≤—ã–µ.
        """
        link_id = (result.get('order_link_id')
                   or result.get('order_id')
                   or f"{copy_order.target_symbol}:{copy_order.target_side}:{int(time.time())}")

        async with self._copy_success_lock:
            if link_id in self._processed_link_ids:
                return False
            self._processed_link_ids.add(link_id)

            # –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç—ã ‚Äî –∑–¥–µ—Å—å –∏ —Ç–æ–ª—å–∫–æ –∑–¥–µ—Å—å
            self.system_stats['successful_copies'] = self.system_stats.get('successful_copies', 0) + 1
            if hasattr(self, 'copy_stats'):
                self.copy_stats['positions_copied'] = self.copy_stats.get('positions_copied', 0) + 1
            return True


    async def _execute_copy_order(self, copy_order: CopyOrder, queue_timestamp: float):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤ orders_log"""
        execution_id = str(uuid.uuid4())[:8]
    
        try:
            sync_delay = time.time() - queue_timestamp
        
            # –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ sys_events
            sys_logger.log_event(
                "INFO",
                "PositionCopyManager",
                f"Executing copy order for {copy_order.target_symbol}",
                {
                    "execution_id": execution_id,
                    "symbol": copy_order.target_symbol,
                    "side": copy_order.target_side,
                    "quantity": float(copy_order.target_quantity),
                    "kelly_fraction": float(copy_order.kelly_fraction),
                    "sync_delay_ms": round(sync_delay * 1000, 2),
                    "order_strategy": copy_order.order_strategy.value,
                    "retry_count": copy_order.retry_count
                }
            )
        
            logger.info(f"Executing copy order for {copy_order.target_symbol} (delay: {sync_delay:.3f}s)")
        
            # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –Ω–∞—á–∞–ª–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞ –≤ orders_log
            orders_logger.log_order(
                account_id=2,  # –û—Å–Ω–æ–≤–Ω–æ–π –∞–∫–∫–∞—É–Ω—Ç
                symbol=copy_order.target_symbol,
                side=copy_order.target_side,
                qty=copy_order.target_quantity,
                status=OrderStatus.PENDING.value,
                exchange_order_id=execution_id,
                attempt=copy_order.retry_count + 1
            )

            # 1) –†–∞–∑–º–µ—â–∞–µ–º –æ—Ä–¥–µ—Ä (AdaptiveOrderManager —É–∂–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç order_link_id)
            start_time = time.time()
            result = await self.order_manager.place_adaptive_order(copy_order)
            execution_time = time.time() - start_time
            latency_ms = int(execution_time * 1000)

            if result.get('success'):
                # –ù–û–í–û–ï: –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ä–¥–µ—Ä–∞ –Ω–∞ FILLED/PLACED
                orders_logger.update_order_status(
                    exchange_order_id=execution_id,
                    new_status=OrderStatus.FILLED.value if result.get('filled') else OrderStatus.PLACED.value,
                    latency_ms=latency_ms
                )
            
                # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≤ sys_events
                sys_logger.log_event(
                    "INFO",
                    "PositionCopyManager",
                    f"Order executed successfully: {copy_order.target_symbol}",
                    {
                        "execution_id": execution_id,
                        "order_id": result.get('order_id'),
                        "order_link_id": result.get('order_link_id'),
                        "symbol": copy_order.target_symbol,
                        "executed_qty": float(result.get('executed_qty', copy_order.target_quantity)),
                        "avg_price": float(result.get('avg_price', 0)),
                        "execution_time_ms": round(execution_time * 1000, 2),
                        "status": "success"
                    }
                )
            
                # 2) –°–ß–Å–¢–ß–ò–ö–ò ‚Äî —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—É—é —Ç–æ—á–∫—É
                accounted = await self._account_success_once(result, copy_order)
                if not accounted:
                    logger.warning(
                        f"Duplicate success ignored for link={result.get('order_link_id') or result.get('order_id')}"
                    )

                # 3) –ü–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–π —Ç—Ä–µ–∫–∏–Ω–≥
                if copy_order.source_signal.signal_type == SignalType.POSITION_OPEN:
                    await self._setup_position_tracking(copy_order, result)
                elif copy_order.source_signal.signal_type == SignalType.POSITION_CLOSE:
                    await self._cleanup_position_tracking(copy_order)

                # 4) Kelly ‚Äî –∑–∞–ø–∏—Å—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å —Å—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞)
                if 'avg_price' in result:
                    pnl_estimate = self._estimate_trade_pnl(copy_order, result)
                    self.kelly_calculator.add_trade_result(
                        copy_order.target_symbol,
                        pnl_estimate,
                        {'copy_order': copy_order, 'result': result}
                    )

                # 5) –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                await send_telegram_alert(
                    f"‚úÖ Position copied: {copy_order.target_symbol} {copy_order.target_side} "
                    f"{copy_order.target_quantity:.6f} (Kelly: {copy_order.kelly_fraction:.3f})"
                )

            else:
                # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á—É –≤ orders_log
                orders_logger.update_order_status(
                    exchange_order_id=execution_id,
                    new_status=OrderStatus.FAILED.value,
                    latency_ms=latency_ms,
                    reason=result.get('error', 'Unknown error')
                )
            
                # –õ–æ–≥–∏—Ä—É–µ–º –Ω–µ—É–¥–∞—á–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≤ sys_events
                sys_logger.log_warning(
                    "PositionCopyManager",
                    f"Order execution failed: {copy_order.target_symbol}",
                    {
                        "execution_id": execution_id,
                        "symbol": copy_order.target_symbol,
                        "error": result.get('error', 'Unknown error'),
                        "retry_count": copy_order.retry_count,
                        "execution_time_ms": round(execution_time * 1000, 2),
                        "status": "failed"
                    }
                )
            
                # –ù–µ—É—Å–ø–µ—Ö ‚Äî —Å—á–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏/–∑–∞–¥–µ—Ä–∂–∫–∏ (–±–µ–∑ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞ —É—Å–ø–µ—Ö–æ–≤)
                self._update_copy_stats(False, sync_delay, copy_order)

                # –ü–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏
                if copy_order.retry_count < COPY_CONFIG['order_retry_attempts']:
                    copy_order.retry_count += 1
                    await asyncio.sleep(COPY_CONFIG['order_retry_delay'] * copy_order.retry_count)
                    await self.copy_queue.put((copy_order.priority, time.time(), copy_order))
                    logger.warning(
                        f"Retrying copy order for {copy_order.target_symbol} (attempt {copy_order.retry_count})"
                    )
                else:
                    logger.error(
                        f"Copy order failed after {COPY_CONFIG['order_retry_attempts']} attempts: "
                        f"{copy_order.target_symbol}"
                    )
                    await send_telegram_alert(
                        f"‚ùå Copy order failed: {copy_order.target_symbol} {copy_order.target_side} "
                        f"{copy_order.target_quantity:.6f}"
                    )

        except Exception as e:
            # –ù–û–í–û–ï: –í —Å–ª—É—á–∞–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è —Ç–∞–∫–∂–µ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ orders_log
            try:
                orders_logger.update_order_status(
                    exchange_order_id=execution_id,
                    new_status=OrderStatus.FAILED.value,
                    reason=str(e)
                )
            except:
                pass  # –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–∫–∏
            
            sys_logger.log_error(
                "PositionCopyManager",
                f"Copy order execution error: {str(e)}",
                {
                    "execution_id": execution_id,
                    "symbol": copy_order.target_symbol,
                    "error_type": type(e).__name__
                }
            )
            logger.error(f"Copy order execution error: {e}")



    
    async def _setup_position_tracking(self, copy_order: CopyOrder, execution_result: Dict[str, Any]):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –ø–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è"""
        try:
            symbol = copy_order.target_symbol
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–∑–∏—Ü–∏–∏
            position_data = {
                'symbol': symbol,
                'side': copy_order.target_side,
                'quantity': copy_order.target_quantity,
                'entry_price': execution_result.get('avg_price', copy_order.target_price),
                'kelly_fraction': copy_order.kelly_fraction,
                'open_time': time.time(),
                'order_id': execution_result.get('order_id')
            }
            
            self.active_positions[symbol] = position_data
            
            # –°–æ–∑–¥–∞–µ–º trailing stop
            market_conditions = await self.order_manager.get_market_analysis(symbol)
            current_price = execution_result.get('avg_price', copy_order.target_price)
            position_value = copy_order.target_quantity * current_price
            
            trailing_stop = self.trailing_manager.create_trailing_stop(
                symbol, copy_order.target_side, current_price, position_value, market_conditions
            )
            
            logger.info(f"Position tracking setup for {symbol}: "
                       f"entry=${current_price:.6f}, trailing_stop=${trailing_stop.stop_price:.6f}")
            
        except Exception as e:
            logger.error(f"Position tracking setup error: {e}")
    
    async def _cleanup_position_tracking(self, copy_order: CopyOrder):
        """–û—á–∏—Å—Ç–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è —Å –∑–∞–ø–∏—Å—å—é –≤ –ë–î"""
        try:
            symbol = copy_order.target_symbol
        
            if symbol in self.active_positions:
                position = self.active_positions[symbol]
            
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º P&L –¥–ª—è Kelly –∞–Ω–∞–ª–∏–∑–∞
                entry_price = position['entry_price']
                exit_price = copy_order.target_price
                quantity = position['quantity']
            
                if position['side'].lower() == 'buy':
                    pnl = (exit_price - entry_price) * quantity
                else:
                    pnl = (entry_price - exit_price) * quantity
            
                # ===== –ù–û–í–´–ô –ö–û–î: –ó–ê–ü–ò–°–¨ –í –ë–î =====
                try:
                    api_payload = {
                        "account_id": 1,
                        "symbol": symbol,
                        "side": position['side'],
                        "qty": str(quantity),
                        "position_idx": position.get('position_idx', 0),
                        "entry_price": str(entry_price),
                        "exit_price": str(exit_price),
                        "realized_pnl": str(pnl),
                        "leverage": position.get('leverage'),
                        "margin_mode": position.get('margin_mode', 'Cross'),
                        "opened_at": position.get('opened_at'),
                        "closed_at": time.time() * 1000,
                        "raw_open": position.get('raw_data', {}),
                        "raw_close": {
                            "exit_price": str(exit_price),
                            "pnl": str(pnl),
                            "cleanup_time": time.time()
                        }
                    }
                
                    async with aiohttp.ClientSession() as session:
                        async with session.post(
                            "http://localhost:8080/api/positions/close",
                            json=api_payload,
                            headers={"Content-Type": "application/json"},
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                logger.info(f"Position cleanup recorded in DB for {symbol}")
                            else:
                                logger.warning(f"Failed to record cleanup in DB: {response.status}")
                            
                except Exception as e:
                    logger.warning(f"Non-critical: Failed to record position cleanup in DB: {e}")
            
                # ===== –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ö–û–î–ê =====
            
                # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ Kelly –∞–Ω–∞–ª–∏–∑
                self.kelly_calculator.add_trade_result(
                    symbol, pnl, 
                    {'position': position, 'exit_price': exit_price}
                )
            
                # –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
                del self.active_positions[symbol]
            
                # –£–¥–∞–ª—è–µ–º trailing stop
                self.trailing_manager.remove_trailing_stop(symbol)
            
                logger.info(f"Position tracking cleanup for {symbol}: P&L=${pnl:.2f}")
        
        except Exception as e:
            logger.error(f"Position tracking cleanup error: {e}")
    
    def _estimate_trade_pnl(self, copy_order: CopyOrder, execution_result: Dict[str, Any]) -> float:
        """–û—Ü–µ–Ω–∫–∞ P&L —Å–¥–µ–ª–∫–∏ (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –¥–ª—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö –ø–æ–∑–∏—Ü–∏–π)"""
        try:
            # –î–ª—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö –ø–æ–∑–∏—Ü–∏–π –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0 (P&L –±—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏)
            if copy_order.source_signal.signal_type == SignalType.POSITION_OPEN:
                return 0.0
            
            # –î–ª—è –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö –ø–æ–∑–∏—Ü–∏–π —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π P&L
            if copy_order.target_symbol in self.active_positions:
                position = self.active_positions[copy_order.target_symbol]
                entry_price = position['entry_price']
                exit_price = execution_result.get('avg_price', copy_order.target_price)
                quantity = copy_order.target_quantity
                
                if position['side'].lower() == 'buy':
                    return (exit_price - entry_price) * quantity
                else:
                    return (entry_price - exit_price) * quantity
            
            return 0.0
            
        except Exception as e:
            logger.error(f"P&L estimation error: {e}")
            return 0.0
    
    def _update_copy_stats(self, success: bool, sync_delay: float, copy_order: CopyOrder):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            if success:
                if copy_order.source_signal.signal_type == SignalType.POSITION_OPEN:
                    self.copy_stats['positions_copied'] += 1
                elif copy_order.source_signal.signal_type == SignalType.POSITION_CLOSE:
                    self.copy_stats['positions_closed'] += 1
                
                self.copy_stats['total_volume_copied'] += copy_order.target_quantity * (copy_order.target_price or 0)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω—é—é –∑–∞–¥–µ—Ä–∂–∫—É —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
            if self.copy_stats['avg_sync_delay'] == 0:
                self.copy_stats['avg_sync_delay'] = sync_delay
            else:
                self.copy_stats['avg_sync_delay'] = (
                    self.copy_stats['avg_sync_delay'] * 0.9 + sync_delay * 0.1
                )
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏
            total_attempts = self.copy_stats['positions_copied'] + self.copy_stats['positions_closed']
            if total_attempts > 0:
                self.copy_stats['copy_success_rate'] = total_attempts / (total_attempts + 1) * 100
            
        except Exception as e:
            logger.error(f"Stats update error: {e}")
    
    async def update_trailing_stops(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö trailing stops —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
        try:
            # –°–æ–±–∏—Ä–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            symbols_to_check = set()

            for position_key, position_data in list(self.active_positions.items()):
                symbol = None
                if isinstance(position_data, dict):
                    symbol = position_data.get('symbol')

                if not symbol:
                    key_str = str(position_key)

                    # –£–±–∏—Ä–∞–µ–º —Å—É—Ñ—Ñ–∏–∫—Å—ã –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Ä–∞–∑–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö
                    for suffix in ('*Buy', '*Sell', '_Buy', '_Sell', ':Buy', ':Sell', 'Buy', 'Sell'):
                        if key_str.endswith(suffix):
                            key_str = key_str[:-len(suffix)]
                            break

                    # –ï—Å–ª–∏ –≤ –∫–æ–Ω—Ü–µ –∫–ª—é—á–∞ –±—ã–ª —Ç–∞–π–º—Å—Ç–∞–º–ø –≤–∏–¥–∞ _1234567890 ‚Äî —É–±–µ—Ä—ë–º –µ–≥–æ
                    if '_' in key_str:
                        left, right = key_str.rsplit('_', 1)
                        if right.isdigit():
                            key_str = left

                    symbol = key_str or None

                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–∏–º–≤–æ–ª –≤ –¥–∞–Ω–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏, —á—Ç–æ–±—ã –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –Ω–µ –ø–∞—Ä—Å–∏—Ç—å –∫–ª—é—á
                    if symbol and isinstance(position_data, dict):
                        position_data['symbol'] = symbol

                if symbol:
                    symbols_to_check.add(symbol)

            if not symbols_to_check:
                logger.debug("No symbols to update trailing stops")
                return

            # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏ —Ä–µ—Ç—Ä–∞–µ–≤)
            prices_cache = {}
            for symbol in symbols_to_check:
                try:
                    ticker_params = {
                        "category": "linear",
                        "symbol": symbol,
                    }
                    ticker_result = await self.main_client._make_request_with_retry(
                        "GET", "market/tickers", ticker_params
                    )
                    if ticker_result and ticker_result.get('retCode') == 0:
                        lst = ticker_result.get('result', {}).get('list', [])
                        if lst:
                            current_price = safe_float(lst[0].get('lastPrice', 0))
                            if current_price > 0:
                                prices_cache[symbol] = current_price
                            else:
                                logger.warning(f"Invalid price for {symbol}: {current_price}")
                    else:
                        logger.warning(f"Failed to get ticker for {symbol}: {ticker_result}")
                except Exception as e:
                    logger.error(f"Error fetching price for {symbol}: {e}")

            # –û–±–Ω–æ–≤–ª—è–µ–º/–ø—Ä–æ–≤–µ—Ä—è–µ–º trailing stops —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–Ω
            for symbol, current_price in prices_cache.items():
                try:
                    self.trailing_manager.update_trailing_stop(symbol, current_price)
                    if self.trailing_manager.check_stop_triggered(symbol, current_price):
                        await self._execute_trailing_stop_exit(symbol, current_price)
                except Exception as e:
                    logger.error(f"Error handling trailing stop for {symbol}: {e}")

        except Exception as e:
            logger.error(f"Critical error in trailing stops update: {e}", exc_info=True)

    
    async def _execute_trailing_stop_exit(self, symbol: str, trigger_price: float):
        """–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –≤—ã—Ö–æ–¥–∞ –ø–æ trailing stop"""
        try:
            if symbol not in self.active_positions:
                return
            
            position = self.active_positions[symbol]
            close_side = "Sell" if position['side'] == "Buy" else "Buy"
            
            # –°–æ–∑–¥–∞–µ–º —ç–∫—Å—Ç—Ä–µ–Ω–Ω—ã–π –æ—Ä–¥–µ—Ä –∑–∞–∫—Ä—ã—Ç–∏—è
            emergency_signal = TradingSignal(
                signal_type=SignalType.POSITION_CLOSE,
                symbol=symbol,
                side=close_side,
                size=position['quantity'],
                price=trigger_price,
                timestamp=time.time(),
                metadata={'reason': 'trailing_stop_triggered'},
                priority=3
            )
            
            copy_order = CopyOrder(
                source_signal=emergency_signal,
                target_symbol=symbol,
                target_side=close_side,
                target_quantity=position['quantity'],
                target_price=trigger_price,
                order_strategy=OrderStrategy.MARKET,
                kelly_fraction=0.0,
                priority=3
            )
            
            # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∏—Å–ø–æ–ª–Ω—è–µ–º
            result = await self.order_manager.place_adaptive_order(copy_order)
            
            if result.get('success'):
                await self._cleanup_position_tracking(copy_order)
                
                await send_telegram_alert(
                    f"üõë Trailing stop triggered: {symbol} closed at ${trigger_price:.6f}"
                )
                
                logger.info(f"Trailing stop executed for {symbol} at ${trigger_price:.6f}")
            else:
                logger.error(f"Trailing stop execution failed for {symbol}")
                await send_telegram_alert(
                    f"‚ùå Trailing stop execution failed for {symbol}"
                )
            
        except Exception as e:
            logger.error(f"Trailing stop execution error: {e}")
    
    def set_copy_mode(self, mode: CopyMode):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∂–∏–º–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        self.copy_mode = mode
        logger.info(f"Copy mode set to: {mode.value}")
    
    def get_copy_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        stats = self.copy_stats.copy()
        stats.update({
            'active_positions': len(self.active_positions),
            'queue_size': self.copy_queue.qsize(),
            'processing_active': self.processing_active,
            'copy_mode': self.copy_mode.value,
            'trailing_stops_active': len(self.trailing_manager.get_all_stops())
        })
        return stats

# ================================
# –°–ò–°–¢–ï–ú–ê –ö–û–ù–¢–†–û–õ–Ø –†–ò–°–ö–û–í
# ================================

class DrawdownController:
    """
    –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è –ø—Ä–æ—Å–∞–¥–∫–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏
    
    –§—É–Ω–∫—Ü–∏–∏:
    - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ—Å–∞–¥–∫–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
    - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –ø—Ä–µ–≤—ã—à–µ–Ω–∏–∏ –ª–∏–º–∏—Ç–æ–≤
    - –ì—Ä–∞–¥—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π
    - –†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –ø—Ä–æ—Å–∞–¥–∫–∏
    """
    
    def __init__(self):
        self.peak_balance = 0.0
        self.daily_start_balance = 0.0
        self.daily_reset_time = 0
    
        # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –õ–∏–º–∏—Ç—ã —Ä–∏—Å–∫–∞ –¥–ª—è –º–µ—Ç–æ–¥–∞ check_risk_limits
        self.max_daily_drawdown = 0.05  # 5% –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–Ω–µ–≤–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞
        self.max_total_drawdown = 0.15  # 15% –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –æ–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞
    
        # –£—Ä–æ–≤–Ω–∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π (–≥—Ä–∞–¥—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)
        self.alert_levels = [0.02, 0.035, 0.05, 0.08, 0.12]  # 2%, 3.5%, 5%, 8%, 12%
        self.alerts_sent = {}
    
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∏—Å–∫–æ–≤
        self.risk_stats = {
            'max_daily_drawdown': 0.0,
            'max_total_drawdown': 0.0,
            'emergency_stops_triggered': 0,
            'recovery_mode_activations': 0,
            'risk_alerts_sent': 0
        }
    
        self.emergency_stop_active = False
        self.recovery_mode_active = False
    
        # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è —Ä–∏—Å–∫–æ–≤
        self.current_balance = 0.0  # –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        self.daily_pnl = 0.0  # –¢–µ–∫—É—â–∏–π –¥–Ω–µ–≤–Ω–æ–π P&L

                # === SAFE-MODE / –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∏—Å–∫–∞ (–Ω–µ –ª–æ–º–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –∫–æ–Ω—Ñ–∏–≥–∏) ===
        # –°–æ–±–∏—Ä–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ñ–∏–≥ –¥–ª—è RiskDataContext –∏–∑ —Ç–≤–æ–µ–≥–æ RISK_CONFIG
        _safe_mode_cfg = {
            'enabled': True,
            'data_stale_ttl_sec': 10.0,   # —Å–∫–æ–ª—å–∫–æ —Å—á–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ ¬´—É—Å—Ç–∞—Ä–µ–≤—à–∏–º–∏¬ª
            'risk_confirm_reads': 2,      # —Å–∫–æ–ª—å–∫–∏–º–∏ —á—Ç–µ–Ω–∏—è–º–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞—Ç—å DD
            'risk_hysteresis': 0.01       # –≥–∏—Å—Ç–µ—Ä–µ–∑–∏—Å 1%
        }
        _risk_cfg_wrapper = {
            'RISK': {'drawdown_limit': RISK_CONFIG.get('max_total_drawdown', 0.15)},
            'SAFE_MODE': _safe_mode_cfg
        }

        self.risk_ctx = RiskDataContext(_risk_cfg_wrapper)
        # notifier –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–≤–æ–π send_telegram_alert, –æ–Ω —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω —Å–≤–µ—Ä—Ö—É
        self.supervisor = HealthSupervisor(_risk_cfg_wrapper, self.risk_ctx, notifier=send_telegram_alert)

        # high-watermark –¥–ª—è –¥–Ω–µ–≤–Ω–æ–π DD (–¥–Ω–µ–≤–Ω–æ–π ¬´–ø–∏–∫¬ª, –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ —Å—á–∏—Ç–∞—Ç—å –¥–Ω–µ–≤–Ω—É—é –ø—Ä–æ—Å–∞–¥–∫—É)
        self.daily_high = 0.0


    async def check_risk_limits(self, current_balance: float = None, 
                                daily_pnl: float = None, 
                                max_drawdown: float = None) -> Dict[str, Any]:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ —Ä–∏—Å–∫–∞ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–π (safe-gate).
        –ü—Ä–∏ –Ω–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ç–∫—Ä—ã—Ç–∏—è (–≤–æ–∑–≤—Ä–∞—â–∞–µ–º ok —Å reason).
        """
        risk_check = {
            'can_trade': True,
            'can_open_position': True,
            'warning': False,
            'emergency_stop': False,
            'reason': 'Normal trading conditions',
            'recommended_position_size_multiplier': 1.0
        }
        try:
            # 1) –ï—Å–ª–∏ –±–∞–ª–∞–Ω—Å –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω ‚Äì –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π –∏–∑–≤–µ—Å—Ç–Ω—ã–π
            if current_balance is None:
                current_balance = self.current_balance if self.current_balance > 0 else None

            # 2) –î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω—ã ‚Üí –ù–ï –±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ç–∫—Ä—ã—Ç–∏–µ (–≤–∞–∂–Ω–æ –¥–ª—è copy-—Å–∏–≥–Ω–∞–ª–æ–≤)
            if current_balance is None or not self.risk_ctx.is_data_reliable():
                risk_check['reason'] = 'Risk data not reliable ‚Äî skip DD gate'
                return risk_check

            # 3) –û–±–Ω–æ–≤–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã —Ä–∏—Å–∫–∞
            await self.supervisor.on_api_success()
            self.risk_ctx.update_equity(current_balance)
            if self.daily_high == 0.0:
                self.daily_high = current_balance
            self.daily_high = max(self.daily_high, current_balance)

            if daily_pnl is None:
                daily_pnl = self.daily_pnl

            # 4) –°—á–∏—Ç–∞–µ–º DD –ª–æ–∫–∞–ª—å–Ω–æ (–∫–∞–∫ –≤ —Ç–≤–æ–µ–π –ª–æ–≥–∏–∫–µ)
            if self.peak_balance <= 0 or current_balance > self.peak_balance:
                self.peak_balance = current_balance

            daily_drawdown = abs(float(daily_pnl)) / current_balance if current_balance > 0 else 0.0
            total_drawdown = (self.peak_balance - current_balance) / self.peak_balance if self.peak_balance > 0 else 0.0

            daily_drawdown = max(0.0, daily_drawdown)
            total_drawdown = max(0.0, total_drawdown)

            # 5) –û–±–Ω–æ–≤–∏–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
            self.current_balance = current_balance
            self.daily_pnl = daily_pnl

            # 6) –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–ª—É—á–∞–∏ ‚Äî —Ç–æ–ª—å–∫–æ –ø–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω–Ω–æ–π DD
            critical_daily = daily_drawdown > (self.max_daily_drawdown * 1.5)
            critical_total = total_drawdown > (self.max_total_drawdown * 1.2)
            if (critical_daily or critical_total) and self.risk_ctx.dd_confirmed():
                self.emergency_stop_active = True
                self.risk_stats['emergency_stops_triggered'] += 1
                risk_check.update({
                    'can_trade': False,
                    'can_open_position': False,
                    'emergency_stop': True,
                    'reason': f'Confirmed critical drawdown: total {total_drawdown:.2%}, daily {daily_drawdown:.2%}'
                })
                return risk_check

            # 7) –ú—è–≥–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è ‚Üí –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ–º/—Å–Ω–∏–∂–∞–µ–º —Ä–∞–∑–º–µ—Ä
            if total_drawdown >= self.max_total_drawdown or daily_drawdown >= self.max_daily_drawdown:
                risk_check.update({
                    'warning': True,
                    'can_open_position': False,
                    'reason': f'Recovery mode gating: total {total_drawdown:.2%}, daily {daily_drawdown:.2%}',
                    'recommended_position_size_multiplier': 0.5
                })

            return risk_check

        except Exception as e:
            logger.error(f"check_risk_limits error: {e}")
            return risk_check

    def can_open_positions(self) -> bool:
        """–ü—É—Å–∫–∞—Ç—å –Ω–æ–≤—ã–µ —Å–¥–µ–ª–∫–∏, –µ—Å–ª–∏ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —Å—Ç–æ–ø –∏ –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å—É–ø–µ—Ä–≤–∏–∑–æ—Ä–æ–º.
        –í–ê–ñ–ù–û: –Ω–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ—Å—Ç—å risk-–¥–∞–Ω–Ω—ã—Ö –ù–ï –±–ª–æ–∫–∏—Ä—É–µ—Ç –æ—Ç–∫—Ä—ã—Ç–∏—è, –Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ."""
        # –ñ—ë—Å—Ç–∫–∏–π —Å—Ç–æ–ø ‚Äì –≤—Å–µ–≥–¥–∞ ¬´–Ω–µ–ª—å–∑—è¬ª
        if getattr(self, "emergency_stop_active", False):
            return False

        # –°—É–ø–µ—Ä–≤–∏–∑–æ—Ä –º–æ–∂–µ—Ç –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ç–∫—Ä—ã—Ç–∏—è (HALTED / copy_enabled=False)
        if hasattr(self, "supervisor"):
            if not self.supervisor.can_open_positions():
                return False

        # –ù–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω—ã–µ risk-–¥–∞–Ω–Ω—ã–µ –Ω–µ –¥–æ–ª–∂–Ω—ã –ø–∞—Ä–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
        if hasattr(self, "risk_ctx") and not self.risk_ctx.is_data_reliable():
            logger.warning("Risk data not reliable ‚Äî skipping DD gate for openings")
            return True

        # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—É—Å–∫–∞–µ–º
        return True



    async def check_drawdown_limits(self, current_balance: float) -> Dict[str, Any]:
        """–ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ –ø—Ä–æ—Å–∞–¥–∫–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –ª–æ–∂–Ω—ã—Ö —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–π"""
        # –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—Ç–∞
        result = {
            'total_drawdown': 0.0,
            'daily_drawdown': 0.0,
            'alerts_triggered': [],
            'emergency_stop_required': False,
            'recovery_mode_required': False
        }

        try:
            # 1) –ï—Å–ª–∏ –±–∞–ª–∞–Ω—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω/–Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω ‚Äî –ù–ï —ç—Å–∫–∞–ª–∏—Ä—É–µ–º DD, —É—Ö–æ–¥–∏–º –º—è–≥–∫–æ
            if current_balance is None or current_balance <= 0:
                sys_logger.log_warning(
                    "DrawdownController",
                    "Invalid balance for drawdown check",
                    {"current_balance": current_balance}
                )
                await self.supervisor.on_api_failure("equity unavailable")
                # –ù–∏–∫–∞–∫–∏—Ö –∞–ª—ë—Ä—Ç–æ–≤ –∏ ES –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç–æ–≤–µ—Ä–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                return result

            # 2) –î–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã ‚Üí –æ–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã
            await self.supervisor.on_api_success()
            self.risk_ctx.update_equity(current_balance)

            # high watermark –¥–ª—è –¥–Ω–µ–≤–Ω–æ–π DD
            if self.daily_high == 0.0:
                self.daily_high = current_balance
            self.daily_high = max(self.daily_high, current_balance)
            self.risk_ctx.update_daily_dd(current_balance, self.daily_high)

            # 3) –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–∏–∫–æ–≤ –∏ —Å—É—Ç–æ—á–Ω–æ–≥–æ —Å–±—Ä–æ—Å–∞ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–≤–æ—é –ª–æ–≥–∏–∫—É)
            if current_balance > self.peak_balance:
                old_peak = self.peak_balance
                self.peak_balance = current_balance
                self.alerts_sent.clear()  # —Å–±—Ä–æ—Å –∞–ª—ë—Ä—Ç–æ–≤ –ø—Ä–∏ –Ω–æ–≤–æ–º –ø–∏–∫–µ
        
                if old_peak > 0:
                    sys_logger.log_event(
                        "INFO",
                        "DrawdownController",
                        "New peak balance reached",
                        {
                            "old_peak": old_peak,
                            "new_peak": self.peak_balance,
                            "increase": self.peak_balance - old_peak
                        }
                    )

            current_day = int(time.time() / 86400)
            if current_day != int(self.daily_reset_time / 86400):
                self.daily_start_balance = current_balance
                self.daily_reset_time = time.time()
                self.daily_high = current_balance  # —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–Ω–µ–≤–Ω–æ–π high
        
                sys_logger.log_event(
                    "INFO",
                    "DrawdownController",
                    "Daily drawdown reset",
                    {"new_daily_start": self.daily_start_balance}
                )

            # 4) –†–∞—Å—á—ë—Ç DD (–∂—ë—Å—Ç–∫–æ ‚â• 0)
            total_drawdown = 0.0
            daily_drawdown = 0.0

            if self.peak_balance > 0:
                total_drawdown = (self.peak_balance - current_balance) / self.peak_balance
            if self.daily_start_balance > 0:
                daily_drawdown = (self.daily_start_balance - current_balance) / self.daily_start_balance

            total_drawdown = max(0.0, float(total_drawdown))
            daily_drawdown = max(0.0, float(daily_drawdown))

            # 5) –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.risk_stats['max_total_drawdown'] = max(self.risk_stats['max_total_drawdown'], total_drawdown)
            self.risk_stats['max_daily_drawdown'] = max(self.risk_stats['max_daily_drawdown'], daily_drawdown)

            # 6) –ì—Ä–∞–¥—É–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ‚Äî –¢–û–õ–¨–ö–û –ø—Ä–∏ –≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
            max_dd = max(total_drawdown, daily_drawdown)
            alerts = self._check_warning_levels(max_dd, total_drawdown, daily_drawdown)
            result['alerts_triggered'] = alerts
    
            # –õ–æ–≥–∏—Ä—É–µ–º –∞–ª–µ—Ä—Ç—ã
            for alert_level in alerts:
                if alert_level not in self.alerts_sent:
                    sys_logger.log_event(
                        "WARNING",
                        "DrawdownController",
                        f"Drawdown alert level {alert_level:.1%} reached",
                        {
                            "alert_level": alert_level,
                            "total_drawdown": round(total_drawdown, 4),
                            "daily_drawdown": round(daily_drawdown, 4),
                            "current_balance": current_balance
                        }
                    )
                
                    # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events –¥–ª—è warning —É—Ä–æ–≤–Ω–µ–π
                    if alert_level >= 0.05:  # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–∏–º—ã–µ —É—Ä–æ–≤–Ω–∏ (5%+)
                        risk_events_logger.log_drawdown_event(
                            account_id=2,
                            drawdown_percent=max_dd,
                            event_type=RiskEventType.DRAWDOWN_WARNING,
                            current_balance=current_balance,
                            peak_balance=self.peak_balance
                        )
                    
                    self.alerts_sent.add(alert_level)

            # 7) –†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è / –≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ (—Ç–æ–ª—å–∫–æ –ø–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–Ω–æ–π –ø—Ä–æ—Å–∞–¥–∫–µ)
            #   - –∫—Ä–∏—Ç: 1.5√ó –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞ –∏–ª–∏ 1.2√ó –æ–±—â–µ–≥–æ –ª–∏–º–∏—Ç–∞
            critical_daily = daily_drawdown > (self.max_daily_drawdown * 1.5)
            critical_total = total_drawdown > (self.max_total_drawdown * 1.2)

            if (critical_daily or critical_total) and self.risk_ctx.dd_confirmed():
                if not self.emergency_stop_active:
                    # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                    risk_events_logger.log_risk_event(
                        account_id=2,
                        event=RiskEventType.EMERGENCY_STOP,
                        reason=f"Critical DD confirmed: total={total_drawdown:.2%}, daily={daily_drawdown:.2%}",
                        value=max(total_drawdown, daily_drawdown)
                    )
                
                    sys_logger.log_warning(
                        "DrawdownController",
                        "EMERGENCY STOP ACTIVATED",
                        {
                            "total_drawdown": round(total_drawdown, 4),
                            "daily_drawdown": round(daily_drawdown, 4),
                            "critical_daily": critical_daily,
                            "critical_total": critical_total,
                            "current_balance": current_balance,
                            "peak_balance": self.peak_balance
                        }
                    )
        
                self.emergency_stop_active = True
                self.risk_stats['emergency_stops_triggered'] += 1
                result['emergency_stop_required'] = True
        
            elif (total_drawdown >= self.max_total_drawdown) or (daily_drawdown >= self.max_daily_drawdown):
                result['recovery_mode_required'] = True
                if not self.recovery_mode_active:
                    # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                    risk_events_logger.log_risk_event(
                        account_id=2,
                        event=RiskEventType.RECOVERY_MODE_ON,
                        reason=f"Threshold exceeded: total={total_drawdown:.2%} (limit {self.max_total_drawdown}), daily={daily_drawdown:.2%} (limit {self.max_daily_drawdown})",
                        value=max(total_drawdown, daily_drawdown)
                    )
                
                    sys_logger.log_warning(
                        "DrawdownController",
                        "Recovery mode activated",
                        {
                            "total_drawdown": round(total_drawdown, 4),
                            "daily_drawdown": round(daily_drawdown, 4),
                            "total_limit": self.max_total_drawdown,
                            "daily_limit": self.max_daily_drawdown
                        }
                    )
                    await self._activate_recovery_mode(total_drawdown)

            # 8) –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ä–µ–ø–æ—Ä—Ç–æ–≤
            result['total_drawdown'] = total_drawdown
            result['daily_drawdown'] = daily_drawdown
            return result

        except Exception as e:
            sys_logger.log_error(
                "DrawdownController",
                f"Drawdown check error: {str(e)}",
                {"error": str(e), "current_balance": current_balance}
            )
            logger.error(f"Drawdown check error: {e}")
            return result

    
    def _assess_risk_level(self, total_dd: float, daily_dd: float) -> RiskLevel:
        """–û—Ü–µ–Ω–∫–∞ —É—Ä–æ–≤–Ω—è —Ä–∏—Å–∫–∞"""
        max_dd = max(total_dd, daily_dd)
        
        if max_dd >= RISK_CONFIG['emergency_stop_threshold']:
            return RiskLevel.CRITICAL
        elif max_dd >= RISK_CONFIG['recovery_mode_threshold']:
            return RiskLevel.HIGH
        elif max_dd >= 0.05:  # 5%
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW
    
    async def _trigger_emergency_stop(self, total_dd: float, daily_dd: float):
        """–≠–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏"""
        try:
            self.emergency_stop_active = True
            self.risk_stats['emergency_stops_triggered'] += 1
            
            reason = f"Emergency stop: Total DD={total_dd:.2%}, Daily DD={daily_dd:.2%}"
            logger.critical(reason)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            await send_telegram_alert(
                f"üö® –≠–ö–°–¢–†–ï–ù–ù–ê–Ø –û–°–¢–ê–ù–û–í–ö–ê –¢–û–†–ì–û–í–õ–ò!\n"
                f"–û–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {total_dd:.2%}\n"
                f"–î–Ω–µ–≤–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {daily_dd:.2%}\n"
                f"–°–∏—Å—Ç–µ–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è –∑–∞—â–∏—Ç—ã –∫–∞–ø–∏—Ç–∞–ª–∞."
            )
            
        except Exception as e:
            logger.error(f"Emergency stop trigger error: {e}")
    
    async def _activate_recovery_mode(self, total_dd: float):
        """–ê–∫—Ç–∏–≤–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
        try:
            self.recovery_mode_active = True
            self.risk_stats['recovery_mode_activations'] += 1
            
            logger.warning(f"Recovery mode activated: Total DD={total_dd:.2%}")
            
            await send_telegram_alert(
                f"‚ö†Ô∏è –†–ï–ñ–ò–ú –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–Ø –ê–ö–¢–ò–í–ò–†–û–í–ê–ù\n"
                f"–û–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {total_dd:.2%}\n"
                f"–†–∞–∑–º–µ—Ä—ã –ø–æ–∑–∏—Ü–∏–π –±—É–¥—É—Ç —Å–Ω–∏–∂–µ–Ω—ã –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è."
            )
            
        except Exception as e:
            logger.error(f"Recovery mode activation error: {e}")
    
    def _check_warning_levels(self, max_dd: float, total_dd: float, daily_dd: float) -> List[str]:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ä–æ–≤–Ω–µ–π –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ –≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö)"""
        triggered_alerts: List[str] = []
        try:
            # –Ω–µ —Ç—Ä–µ–≤–æ–∂–∏–º, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ–Ω–∞–¥—ë–∂–Ω—ã
            if not self.risk_ctx.is_data_reliable():
                return triggered_alerts

            for i, level in enumerate(self.alert_levels):
                alert_key = f'level_{i}'
                if max_dd >= level and alert_key not in self.alerts_sent:
                    alert_message = (
                        f"‚ö†Ô∏è –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –û –ü–†–û–°–ê–î–ö–ï {level:.1%}\n"
                        f"–û–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {total_dd:.2%}\n"
                        f"–î–Ω–µ–≤–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {daily_dd:.2%}\n"
                        f"–£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {self._assess_risk_level(total_dd, daily_dd).value}"
                    )

                    # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram –∏–∑ sync-–∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (–±–µ–∑ await)
                    try:
                        asyncio.create_task(send_telegram_alert(alert_message))
                    except RuntimeError:
                        # –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Ü–∏–∫–ª –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
                        asyncio.get_event_loop().create_task(send_telegram_alert(alert_message))

                    self.alerts_sent[alert_key] = time.time()
                    self.risk_stats['risk_alerts_sent'] += 1
                    triggered_alerts.append(f"Level {level:.1%}")

                    logger.warning(f"Risk alert triggered: {level:.1%}")

            return triggered_alerts

        except Exception as e:
            logger.error(f"Warning levels check error: {e}")
            return []


    
    def calculate_recovery_parameters(self, current_drawdown: float) -> Dict[str, float]:
        """–†–∞—Å—á–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –ø—Ä–æ—Å–∞–¥–∫–∏"""
        try:
            if current_drawdown <= 0.05:  # –î–æ 5% - –Ω–æ—Ä–º–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
                return {
                    'position_size_multiplier': 1.0,
                    'max_concurrent_positions': COPY_CONFIG['max_concurrent_positions'],
                    'risk_per_trade': KELLY_CONFIG['max_kelly_fraction']
                }
            
            # –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–æ–≤ –ø—Ä–∏ –ø—Ä–æ—Å–∞–¥–∫–µ
            recovery_factor = max(0.3, 1 - (current_drawdown * 2))
            
            return {
                'position_size_multiplier': recovery_factor,
                'max_concurrent_positions': max(1, int(COPY_CONFIG['max_concurrent_positions'] * recovery_factor)),
                'risk_per_trade': KELLY_CONFIG['max_kelly_fraction'] * recovery_factor
            }
            
        except Exception as e:
            logger.error(f"Recovery parameters calculation error: {e}")
            return {
                'position_size_multiplier': 0.5,
                'max_concurrent_positions': 1,
                'risk_per_trade': 0.01
            }
    
    def reset_emergency_stop(self):
        """–°–±—Ä–æ—Å —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ (—Ç–æ–ª—å–∫–æ –≤—Ä—É—á–Ω—É—é)"""
        self.emergency_stop_active = False
        self.recovery_mode_active = False
        logger.info("Emergency stop and recovery mode reset")
    
    def get_risk_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–∏—Å–∫–æ–≤"""
        stats = self.risk_stats.copy()
        stats.update({
            'peak_balance': self.peak_balance,
            'daily_start_balance': self.daily_start_balance,
            'emergency_stop_active': self.emergency_stop_active,
            'recovery_mode_active': self.recovery_mode_active,
            'alerts_sent_count': len(self.alerts_sent)
        })
        return stats

# ================================
# –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° –°–ò–°–¢–ï–ú–´ –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø (–≠–¢–ê–ü 2)
# ================================

class Stage2CopyTradingSystem:
    """
    –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ—Ä–≥–æ–≤–ª–∏ - –≠—Ç–∞–ø 2
    
    –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:
    - FinalTradingMonitor (–≠—Ç–∞–ø 1) –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
    - PositionCopyManager –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π
    - DrawdownController –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏
    - Kelly Criterion –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–π
    - Trailing Stop-Loss –¥–ª—è –∑–∞—â–∏—Ç—ã –ø—Ä–∏–±—ã–ª–∏
    """
    
    def __init__(
        self,
        source_client=None,
        main_client=None,
        base_monitor: Optional[FinalTradingMonitor] = None,
    ):
        # 1) –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–Ω–µ—à–Ω–∏–π –º–æ–Ω–∏—Ç–æ—Ä, –µ—Å–ª–∏ –æ–Ω –ø–µ—Ä–µ–¥–∞–Ω
        self.base_monitor = base_monitor or FinalTradingMonitor(
            source_client=source_client,
            main_client=main_client,
        )

        # 2) –ï–¥–∏–Ω–æ–æ–±—Ä–∞–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∫–ª–∏–µ–Ω—Ç–æ–≤ (–Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–µ–π –º–æ–Ω–∏—Ç–æ—Ä–∞)
        self.source_client = getattr(self.base_monitor, "source_client", source_client)
        self.main_client   = getattr(self.base_monitor, "main_client",   main_client)

        # 3) –§–ª–∞–≥–∏ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞/—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
        self._started = False
        self._handlers_registered = False

        # 4) –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≠—Ç–∞–ø–∞ 2
        self.copy_manager = PositionCopyManager(
            self.source_client,
            self.main_client,
        )
        self.drawdown_controller = DrawdownController()

        # 5) –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
        self.system_active = False
        self.copy_enabled = True
        self.demo_mode = False
        self.last_balance_check = 0
        self.balance_check_interval = 60  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É

        # 6) –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã
        self.system_stats = {
            "start_time": 0,
            "uptime": 0,
            "total_signals_processed": 0,
            "successful_copies": 0,
            "failed_copies": 0,
            "emergency_stops": 0,
            "recovery_activations": 0,
        }

        # 7) –î–æ–ø. –ø–æ–ª—è
        self._last_stage2_report_ts = 0.0

        # –í–ê–ñ–ù–û: –Ω–µ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –Ω–µ –ø–ª–æ–¥–∏—Ç—å –¥—É–±–ª–∏.
        # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç –æ–¥–∏–Ω —Ä–∞–∑ –≤ start_system() —á–µ—Ä–µ–∑
        # await self.copy_manager.start_copying()

        logger.info(
            "Stage 2 Copy Trading System initialized (monitor=%s)",
            type(self.base_monitor).__name__,
        )
    
    async def initialize(self):
        """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            logger.info("Initializing Stage 2 Copy Trading System...")
    
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
            self.kelly_calculator = AdvancedKellyCalculator()
    
            self.copy_manager = PositionCopyManager(
                self.base_monitor.source_client,
                self.base_monitor.main_client
            )
    
            self.trailing_manager = DynamicTrailingStopManager()
            self.drawdown_controller = DrawdownController()
            self.order_manager = AdaptiveOrderManager(self.base_monitor.main_client)
    
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —á–µ—Ä–µ–∑ WebSocket –º–µ–Ω–µ–¥–∂–µ—Ä
            if hasattr(self.base_monitor, 'websocket_manager'):
                self.base_monitor.websocket_manager.register_handler(
                    'position_update', 
                    self.handle_position_signal
                )
                logger.info("Copy signal handler registered through WebSocket manager")
            
                # ‚úÖ –ù–û–í–û–ï: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
                handlers = self.base_monitor.websocket_manager.message_handlers.get('position_update', [])
                logger.info(f"Registered position handlers count: {len(handlers)}")
            
                # ‚úÖ –ù–û–í–û–ï: –¢–µ—Å—Ç–æ–≤—ã–π –≤—ã–∑–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
                try:
                    test_position = {
                        'symbol': 'TEST',
                        'size': '0.0',
                        'side': 'Buy',
                        'markPrice': '0'
                    }
                    await self.handle_position_signal(test_position)
                    logger.info("‚úÖ Test position signal handled successfully")
                except Exception as e:
                    logger.warning(f"Test position signal failed: {e}")
    
            self.system_active = True
            logger.info("‚úÖ Stage 2 Copy Trading System initialized successfully")
    
        except Exception as e:
            logger.error(f"Stage 2 initialization error: {e}")
            raise

    def register_ws_handlers(self, ws_manager):
        if getattr(self, "_position_handler_registered", False):
            return
        ws_manager.register_handler("position_update", self.handle_position_signal)
        self._position_handler_registered = True

    def get_integration_status(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º"""
        try:
            return {
                'system_active': self.system_active,
                'copy_enabled': self.copy_enabled,
                'base_monitor_connected': hasattr(self, 'base_monitor') and self.base_monitor is not None,
                'copy_manager_ready': hasattr(self, 'copy_manager') and self.copy_manager is not None,
                'signal_integration_active': hasattr(self.base_monitor, 'signal_processor') and 
                                           hasattr(self.base_monitor.signal_processor, '_copy_system_callback'),
                'demo_mode': getattr(self, 'demo_mode', True),
                'total_signals_processed': self.system_stats.get('total_signals_processed', 0),
                'successful_copies': self.system_stats.get('successful_copies', 0),
                'failed_copies': self.system_stats.get('failed_copies', 0)
            }
        except Exception as e:
            logger.error(f"Integration status error: {e}")
            return {'error': str(e)}

    async def handle_position_update(self, data):
        """
        –û–±–µ—Ä—Ç–∫–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å position_handlers –∏–∑ WebSocketManager.
        –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ —Å–ø–∏—Å–∫–∞ position_handlers –∏ –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π handle_position_signal.
        """
        try:
            # –ï—Å–ª–∏ —ç—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å –º–∞—Å—Å–∏–≤–æ–º –ø–æ–∑–∏—Ü–∏–π (–æ—Ç reconcile)
            if isinstance(data, dict) and 'data' in data:
                items = data.get('data', [])
                for item in items:
                    await self.handle_position_signal(item)
            # –ï—Å–ª–∏ —ç—Ç–æ –æ–¥–∏–Ω–æ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è  
            elif isinstance(data, dict):
                await self.handle_position_signal(data)
            else:
                logger.warning(f"Unknown position update format: {type(data)}")
            
        except Exception as e:
            logger.error(f"handle_position_update wrapper error: {e}")

    async def process_copy_signal(self, signal: TradingSignal):
        """
        –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è Stage2CopyTradingSystem.
        –î–æ–±–∞–≤–ª–µ–Ω —Ä–µ–∞–ª—å–Ω—ã–π bypass –¥–ª—è /force_copy (metadata.force_copy=True),
        –≥–ª–æ–±–∞–ª—å–Ω—ã–π gate –æ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ —Ä–∏—Å–∫–∞ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ù–ï force_copy.
        –î–µ–ª–µ–≥–∏—Ä—É–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≤ PositionCopyManager.
        """
        try:
            # ---- –∏–∑–≤–ª–µ–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ–ª—è –∏ —Ñ–ª–∞–≥ —Ñ–æ—Ä—Å-—Ä–µ–∂–∏–º–∞
            symbol = getattr(signal, 'symbol', None)
            side   = getattr(signal, 'side', None)
            size   = float(getattr(signal, 'size', 0) or 0)
            is_force = bool((getattr(signal, "metadata", {}) or {}).get("force_copy", False))

            logger.info("üîÑ COPY SIGNAL RECEIVED: %s %s %s", symbol, side, size)

            # 0) –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã
            if not self.system_active:
                logger.warning("Copy system not active - ignoring signal")
                await send_telegram_alert(
                    f"‚ö†Ô∏è **–°–ò–°–¢–ï–ú–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –ù–ï–ê–ö–¢–ò–í–ù–ê**\n"
                    f"–ü—Ä–æ–ø—É—â–µ–Ω —Å–∏–≥–Ω–∞–ª: {symbol} {side}\n"
                    "–ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"
                )
                return

            if not self.copy_enabled:
                logger.warning("Copy disabled - ignoring signal")
                await send_telegram_alert(
                    f"‚ö†Ô∏è **–ö–û–ü–ò–†–û–í–ê–ù–ò–ï –û–¢–ö–õ–Æ–ß–ï–ù–û**\n"
                    f"–ü—Ä–æ–ø—É—â–µ–Ω —Å–∏–≥–Ω–∞–ª: {symbol} {side}\n"
                    "–í–∫–ª—é—á–∏—Ç–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö"
                )
                return

            # 1) –ì–ª–æ–±–∞–ª—å–Ω—ã–π gate –æ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ —Ä–∏—Å–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–π)
            #    –ü—Ä–∏–º–µ–Ω—è–µ–º –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –ù–ï force_copy.
            if signal.signal_type == SignalType.POSITION_OPEN and not is_force:
                if hasattr(self, 'drawdown_controller') and hasattr(self.drawdown_controller, 'can_open_positions'):
                    if not self.drawdown_controller.can_open_positions():
                        mode = getattr(getattr(self.drawdown_controller, 'supervisor', None), 'mode', None)
                        mode_name = getattr(mode, 'value', str(mode)) if mode is not None else 'unknown'
                    
                        # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                        risk_events_logger.log_position_rejection(
                            account_id=2,
                            symbol=symbol,
                            requested_size=size,
                            reason=f"Blocked by risk manager: {mode_name} mode"
                        )
                    
                        logger.warning("Cannot open new positions: system in %s mode", mode_name)
                        await send_telegram_alert(
                            "üõ°Ô∏è **–†–ò–°–ö-–ú–ï–ù–ï–î–ñ–ú–ï–ù–¢: –ë–õ–û–ö–ò–†–û–í–ö–ê –û–¢–ö–†–´–¢–ò–Ø**\n"
                            f"–°–∏–≥–Ω–∞–ª: {symbol} {side}\n"
                            f"–†–µ–∂–∏–º: {mode_name}"
                        )
                        return

            # –ï—Å–ª–∏ –ø—Ä–∏—à—ë–ª –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª ‚Äî —è–≤–Ω–æ –ª–æ–≥–∏—Ä—É–µ–º –∏ —É–≤–µ–¥–æ–º–ª—è–µ–º
            if is_force:
                logger.warning("FORCED COPY OVERRIDE: proceeding to open %s %s %s", symbol, side, size)
                try:
                    await send_telegram_alert(
                        f"‚ö°Ô∏è **FORCED COPY**: –∏—Å–ø–æ–ª–Ω—è–µ–º {symbol} {side} {size} (–æ–±—Ö–æ–¥ DD-–≥–µ–π—Ç–∞)"
                    )
                except Exception:
                    pass

            # 2) –ü–æ–¥—Ä–æ–±–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤ —Ä–∏—Å–∫–∞ (—Ç–≤–æ—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ª–æ–≥–∏–∫–∞)
            #    –ë–ª–æ–∫–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ù–ï force_copy.
            if hasattr(self, 'drawdown_controller'):
                try:
                    risk_check = await self.drawdown_controller.check_risk_limits()
                    if signal.signal_type == SignalType.POSITION_OPEN and not is_force \
                        and not risk_check.get('can_open_position', True):
                    
                        # –ù–û–í–û–ï: –õ–æ–≥–∏—Ä—É–µ–º –≤ risk_events
                        risk_events_logger.log_position_rejection(
                            account_id=2,
                            symbol=symbol,
                            requested_size=size,
                            reason=risk_check.get('reason', 'Risk limits exceeded')
                        )
                    
                        logger.warning("Risk limits prevent copying: %s", risk_check.get('reason', 'Unknown'))
                        await send_telegram_alert(
                            "üõ°Ô∏è **–†–ò–°–ö-–ú–ï–ù–ï–î–ñ–ú–ï–ù–¢ –ë–õ–û–ö–ò–†–û–í–ê–õ –ö–û–ü–ò–†–û–í–ê–ù–ò–ï**\n"
                            f"–°–∏–≥–Ω–∞–ª: {symbol} {side}\n"
                            f"–ü—Ä–∏—á–∏–Ω–∞: {risk_check.get('reason', 'Risk limits')}"
                        )
                        return
                except Exception as e:
                    logger.warning(f"Risk check error: {e}")
                    # –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º

            # 3) –î–µ–ª–µ–≥–∏—Ä—É–µ–º –≤ copy_manager, –≥–¥–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω—É–∂–Ω—ã–µ –º–µ—Ç–æ–¥—ã
            if signal.signal_type == SignalType.POSITION_OPEN:
                await self._handle_position_open_for_copy(signal)
            elif signal.signal_type == SignalType.POSITION_CLOSE:
                await self._handle_position_close_for_copy(signal)
            elif signal.signal_type == SignalType.POSITION_MODIFY:
                await self._handle_position_modify_for_copy(signal)
            else:
                logger.warning(f"Unknown signal type: {signal.signal_type}")
                return

            # 4) –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.system_stats['total_signals_processed'] += 1
            self.system_stats['successful_copies'] += 1

            # 5) –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ–±—Ä–∞–±–æ—Ç–∫–µ
            forced_note = " (FORCED)" if is_force else ""
            await send_telegram_alert(
                "‚úÖ **–°–ò–ì–ù–ê–õ –û–ë–†–ê–ë–û–¢–ê–ù**\n"
                f"Action: {signal.signal_type.value}{forced_note}\n"
                f"Symbol: {symbol}\n"
                f"Size: {size:.6f}\n"
                "Status: –î–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–æ –≤ PositionCopyManager"
            )

        except Exception as e:
            logger.error(f"Copy signal processing error: {e}")
            self.system_stats['failed_copies'] += 1
            await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø**: {str(e)}")

    async def _handle_position_open_for_copy(self, signal):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è - –ü–û–õ–ù–ê–Ø –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        try:
            logger.info(f"üü¢ COPYING POSITION OPEN: {signal.symbol}")
    
            # –ü–æ–ª—É—á–∞–µ–º –±–∞–ª–∞–Ω—Å—ã –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ä–∞–∑–º–µ—Ä–∞
            source_balance = 0.0
            main_balance = 0.0
    
            try:
                source_balance = await self.base_monitor.source_client.get_balance()
                main_balance = await self.base_monitor.main_client.get_balance()
            except Exception as e:
                logger.error(f"Balance retrieval error: {e}")
                await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ü–û–õ–£–ß–ï–ù–ò–Ø –ë–ê–õ–ê–ù–°–û–í**: {str(e)}")
                return
        
            if source_balance <= 0 or main_balance <= 0:
                logger.error("Invalid balances for copying")
                await send_telegram_alert("‚ùå **–ù–ï–î–û–ü–£–°–¢–ò–ú–´–ï –ë–ê–õ–ê–ù–°–´ –î–õ–Ø –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø**")
                return
    
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
            try:
                # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –±–∞–ª–∞–Ω—Å–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
                source_position_value = signal.size * signal.price
                source_percentage = source_position_value / source_balance
        
                # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫ –æ—Å–Ω–æ–≤–Ω–æ–º—É –±–∞–ª–∞–Ω—Å—É
                target_value = main_balance * source_percentage
                target_size = target_value / signal.price
        
                # ‚úÖ KELLY CRITERION: –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω, –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä
                # ‚úÖ KELLY CRITERION: –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤–ª–∏—è–Ω–∏–µ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –∫–æ—Ä–∏–¥–æ—Ä–µ
                if hasattr(self, 'kelly_calculator'):
                    try:
                        base_target_size = target_size  # –∑–∞–ø–æ–º–Ω–∏–º –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é
                        kelly_data = await self.kelly_calculator.calculate_optimal_size(
                            signal.symbol, target_size, signal.price
                        )
                        if kelly_data['recommended_size'] > 0:
                            ksize = kelly_data['recommended_size']
                            k_min = COPY_CONFIG.get('kelly_min_mult', 0.5)
                            k_max = COPY_CONFIG.get('kelly_max_mult', 2.0)
                            target_size = min(max(ksize, base_target_size * k_min), base_target_size * k_max)
                            logger.info(f"Kelly adjustment: {ksize:.6f} -> bounded {target_size:.6f} "
                                        f"(bounds {k_min}x..{k_max}x of {base_target_size:.6f})")
                    except Exception as e:
                        logger.warning(f"Kelly calculation error: {e}")

        
                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ (–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å)
                max_position_value = main_balance * 0.1  # –ú–∞–∫—Å–∏–º—É–º 10% –æ—Ç –±–∞–ª–∞–Ω—Å–∞
                if target_value > max_position_value:
                    target_size = max_position_value / signal.price
                    logger.info(f"Position size limited for safety: {target_size:.6f}")
            
                logger.info(f"üìä COPY CALCULATION: Source ${source_position_value:.2f} ({source_percentage:.2%}) -> Target ${target_size * signal.price:.2f}")
        
                # ‚úÖ –†–ï–ê–õ–¨–ù–û–ï –†–ê–ó–ú–ï–©–ï–ù–ò–ï –û–†–î–ï–†–ê
                if hasattr(self, 'copy_manager') and hasattr(self.copy_manager, 'order_manager'):
                    try:
                        # –í –¥–µ–º–æ —Ä–µ–∂–∏–º–µ —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏—Ä—É–µ–º –ë–ï–ó –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                        if getattr(self, 'demo_mode', True):
                            logger.info(f"üîÑ DEMO MODE: Would place order {signal.symbol} {signal.side} {target_size:.6f}")
                        
                            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
                            if hasattr(self.copy_manager, 'active_positions'):
                                self.copy_manager.active_positions[signal.symbol] = {
                                    'symbol': signal.symbol,
                                    'side': signal.side,
                                    'size': target_size,
                                    'entry_price': signal.price,
                                    'timestamp': time.time(),
                                    'source_signal_id': getattr(signal, 'id', None)
                                }
                        
                            # –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤ DEMO —Ä–µ–∂–∏–º–µ
                        
                        else:
                            # LIVE —Ä–µ–∂–∏–º - —Ä–µ–∞–ª—å–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ
                            from stage2_copy_system import CopyOrder, OrderStrategy
                        
                            copy_order = CopyOrder(
                                source_signal=signal,
                                target_symbol=signal.symbol,
                                target_side=signal.side,
                                target_quantity=target_size,
                                target_price=signal.price,
                                kelly_fraction=target_size / signal.size if signal.size > 0 else 1.0,
                                priority=3,
                                order_strategy=OrderStrategy.MARKET
                            )
                        
                            order_result = await self.copy_manager.order_manager.place_adaptive_order(copy_order)
                    
                            if order_result.get('success'):
                                logger.info(f"‚úÖ Order placed successfully: {order_result.get('order_id', 'N/A')}")
                            
                                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
                                if hasattr(self.copy_manager, 'active_positions'):
                                    self.copy_manager.active_positions[signal.symbol] = {
                                        'symbol': signal.symbol,
                                        'side': signal.side,
                                        'size': target_size,
                                        'entry_price': signal.price,
                                        'timestamp': time.time(),
                                        'source_signal_id': getattr(signal, 'id', None),
                                        'order_id': order_result.get('order_id')
                                    }
                            
                                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¢–û–õ–¨–ö–û –≤ LIVE —Ä–µ–∂–∏–º–µ
                                if hasattr(self.copy_manager, 'copy_stats'):
                                    ##self.copy_manager.copy_stats['positions_copied'] += 1
                                    self.copy_manager.copy_stats['total_volume_copied'] += target_size * signal.price
                            
                                # –°–æ–∑–¥–∞–µ–º trailing stop
                                if hasattr(self.copy_manager, 'trailing_manager'):
                                    try:
                                        market_conditions = await self.copy_manager.order_manager.get_market_analysis(signal.symbol)
                                    
                                        trailing_stop = self.copy_manager.trailing_manager.create_trailing_stop(
                                            symbol=signal.symbol,
                                            side=signal.side,
                                            current_price=signal.price,
                                            position_size=target_size * signal.price,
                                            market_conditions=market_conditions
                                        )
                                    
                                        if trailing_stop:
                                            logger.info(f"‚úÖ Trailing stop created for {signal.symbol}: "
                                                      f"stop_price={trailing_stop.stop_price:.2f}, "
                                                      f"distance={trailing_stop.distance_percent:.2%}")
                                        
                                    except Exception as e:
                                        logger.error(f"Trailing stop creation error: {e}")
                            
                            else:
                                error_msg = order_result.get('error', 'Unknown error')
                                raise Exception(f"Order failed: {error_msg}")
                        
                    except Exception as e:
                        logger.error(f"Order placement error: {e}")
                        await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –†–ê–ó–ú–ï–©–ï–ù–ò–Ø –û–†–î–ï–†–ê**: {str(e)}")
                        return
        
                # –£—Å–ø–µ—à–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                await send_telegram_alert(
                    f"‚úÖ **–ü–û–ó–ò–¶–ò–Ø –°–ö–û–ü–ò–†–û–í–ê–ù–ê**\n"
                    f"Symbol: {signal.symbol}\n"
                    f"Side: {signal.side}\n"
                    f"Original: {signal.size:.6f} (${source_position_value:.2f})\n"
                    f"Copy: {target_size:.6f} (${target_size * signal.price:.2f})\n"
                    f"Ratio: {source_percentage:.2%}\n"
                    f"Mode: {'DEMO' if getattr(self, 'demo_mode', True) else 'LIVE'}"
                )
        
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —É—Å–ø–µ—Ö–∞
                ##self.system_stats['successful_copies'] += 1
        
            except Exception as e:
                logger.error(f"Position size calculation error: {e}")
                await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –†–ê–°–ß–ï–¢–ê –†–ê–ó–ú–ï–†–ê**: {str(e)}")
        
        except Exception as e:
            logger.error(f"Position copy open error: {e}")
            await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –û–¢–ö–†–´–¢–ò–Ø**: {str(e)}")

    async def _handle_position_close_for_copy(self, signal):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å –∑–∞–ø–∏—Å—å—é –≤ –ë–î"""
        try:
            logger.info(f"üî¥ COPYING POSITION CLOSE: {signal.symbol}")
        
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ö–æ–¥—è—â–µ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
            logger.info(f"[DEBUG] Incoming signal data: symbol={signal.symbol}, price={signal.price}, timestamp={signal.timestamp}")
        
            # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–ª—é—á —Å —É—á–µ—Ç–æ–º side
            position_key = f"{signal.symbol}_{signal.side}"
            position_to_close = None
            if hasattr(self.copy_manager, 'active_positions'):
                # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Å —Å–æ—Å—Ç–∞–≤–Ω—ã–º –∫–ª—é—á–æ–º
                position_to_close = self.copy_manager.active_positions.get(position_key)
                if not position_to_close:
                    # Fallback –Ω–∞ –ø—Ä–æ—Å—Ç–æ–π –∫–ª—é—á –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    position_to_close = self.copy_manager.active_positions.get(signal.symbol)
            
                # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                if position_to_close:
                    logger.info(f"[DEBUG] Found position_to_close: {position_to_close}")
                    logger.info(f"[DEBUG] Position fields: side={position_to_close.get('side')}, size={position_to_close.get('size')}, entry_price={position_to_close.get('entry_price')}, leverage={position_to_close.get('leverage')}")
                else:
                    logger.warning(f"[DEBUG] No position found in active_positions for {signal.symbol} (tried keys: {position_key}, {signal.symbol})")

            if not position_to_close:
                logger.warning(f"No active position found to close: {signal.symbol}")
                await send_telegram_alert(
                    f"‚ö†Ô∏è **–ù–ï–¢ –ü–û–ó–ò–¶–ò–ò –î–õ–Ø –ó–ê–ö–†–´–¢–ò–Ø**\n"
                    f"Symbol: {signal.symbol}\n"
                    "–í–æ–∑–º–æ–∂–Ω–æ –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –±—ã–ª–∞ –∑–∞–∫—Ä—ã—Ç–∞ –∏–ª–∏ –Ω–µ –±—ã–ª–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞"
                )
                return

            # ‚úÖ –†–ï–ê–õ–¨–ù–û–ï –ó–ê–ö–†–´–¢–ò–ï –ü–û–ó–ò–¶–ò–ò
            if hasattr(self, 'copy_manager') and hasattr(self.copy_manager, 'order_manager'):
                try:
                    if getattr(self, 'demo_mode', True):
                        logger.info(f"üîÑ DEMO MODE: Would close position {signal.symbol}")
            
                        # –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π (–ø—Ä–æ–±—É–µ–º –æ–±–∞ –∫–ª—é—á–∞)
                        if hasattr(self.copy_manager, 'active_positions'):
                            if position_key in self.copy_manager.active_positions:
                                del self.copy_manager.active_positions[position_key]
                            elif signal.symbol in self.copy_manager.active_positions:
                                del self.copy_manager.active_positions[signal.symbol]
                
                        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                        if hasattr(self.copy_manager, 'copy_stats'):
                            self.copy_manager.copy_stats['positions_closed'] += 1
                
                    else:
                        # –†–µ–∞–ª—å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ
                        close_side = 'Sell' if position_to_close['side'] == 'Buy' else 'Buy'
                        close_result = await self.copy_manager.order_manager.place_order(
                            symbol=signal.symbol,
                            side=close_side,
                            size=position_to_close['size'],
                            order_type='Market'
                        )
                
                        if close_result['success']:
                            logger.info(f"‚úÖ Position closed successfully: {close_result['order_id']}")
                            # –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
                            if hasattr(self.copy_manager, 'active_positions'):
                                if position_key in self.copy_manager.active_positions:
                                    del self.copy_manager.active_positions[position_key]
                                elif signal.symbol in self.copy_manager.active_positions:
                                    del self.copy_manager.active_positions[signal.symbol]
                        else:
                            raise Exception(f"Close failed: {close_result['error']}")
                
                except Exception as e:
                    logger.error(f"Position close error: {e}")
                    await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ó–ê–ö–†–´–¢–ò–Ø –ü–û–ó–ò–¶–ò–ò**: {str(e)}")
                    return
    
            # ===== –ó–ê–ü–ò–°–¨ –í –ë–î –ß–ï–†–ï–ó WEB API –° –ü–û–õ–£–ß–ï–ù–ò–ï–ú –ü–û–õ–ù–´–• –î–ê–ù–ù–´–• =====
            try:
                import aiohttp
                import json
                import psycopg2
            
                # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
                logger.info(f"[DEBUG] Fetching position data from DB for {signal.symbol}")
            
                entry_price = None
                leverage = None
                margin_mode = 'Cross'
                raw_open = {}
            
                try:
                    conn = psycopg2.connect("postgresql://sa:1Qaz2wsX@127.0.0.1:5432/trading_bot")
                    cur = conn.cursor()
                    cur.execute("""
                        SELECT entry_price, leverage, margin_mode, raw::text, qty, side
                        FROM positions_open 
                        WHERE account_id = 1 AND symbol = %s 
                        LIMIT 1
                    """, (signal.symbol,))
                    db_position = cur.fetchone()
                
                    if db_position:
                        logger.info(f"[DEBUG] Found DB position: entry_price={db_position[0]}, leverage={db_position[1]}, margin_mode={db_position[2]}")
                        entry_price = str(db_position[0]) if db_position[0] else None
                        leverage = int(db_position[1]) if db_position[1] else None
                        margin_mode = db_position[2] or 'Cross'
                        if db_position[3]:
                            raw_open = json.loads(db_position[3])
                            logger.info(f"[DEBUG] Raw open data keys: {list(raw_open.keys())[:10]}")
                    else:
                        logger.warning(f"[DEBUG] No position found in DB for {signal.symbol}")
                    
                    cur.close()
                    conn.close()
                except Exception as db_error:
                    logger.error(f"[DEBUG] DB fetch error: {db_error}")
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ position_to_close –∫–∞–∫ fallback
                    entry_price = str(position_to_close.get('entry_price', 0)) if position_to_close.get('entry_price') else None
                    leverage = position_to_close.get('leverage')
                    margin_mode = position_to_close.get('margin_mode', 'Cross')
            
                # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è API
                api_payload = {
                    "account_id": 1,
                    "symbol": signal.symbol,
                    "side": position_to_close.get('side', signal.side),  # –ò—Å–ø–æ–ª—å–∑—É–µ–º side –∏–∑ –ø–æ–∑–∏—Ü–∏–∏ –∏–ª–∏ —Å–∏–≥–Ω–∞–ª–∞
                    "qty": str(position_to_close.get('size', 0)),
                    "position_idx": 0,
                    "entry_price": entry_price,
                    "exit_price": str(signal.price) if signal.price else None,
                    "mark_price": str(signal.price) if signal.price else None,
                    "leverage": leverage,
                    "margin_mode": margin_mode,
                    "liq_price": str(position_to_close.get('liq_price')) if position_to_close.get('liq_price') else None,
                    "realized_pnl": None,  # –ë—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –≤ API
                    "fees": None,
                    "exchange_position_id": position_to_close.get('exchange_position_id'),
                    "opened_at": position_to_close.get('opened_at') or position_to_close.get('timestamp'),
                    "closed_at": signal.timestamp * 1000 if signal.timestamp else None,
                    "raw_open": raw_open or position_to_close.get('raw_open', {}),
                    "raw_close": {
                        "symbol": signal.symbol,
                        "side": position_to_close.get('side', signal.side),
                        "markPrice": str(signal.price) if signal.price else None,
                        "size": "0",
                        "closedTime": str(int(signal.timestamp * 1000)) if signal.timestamp else None,
                        "signal_metadata": signal.metadata if hasattr(signal, 'metadata') else {}
                    }
                }
            
                logger.info(f"[DEBUG] API payload prepared: entry_price={api_payload['entry_price']}, exit_price={api_payload['exit_price']}, leverage={api_payload['leverage']}")
        
                # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –≤—ã–∑–æ–≤ Web API
                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        "http://localhost:8080/api/positions/close",
                        json=api_payload,
                        headers={"Content-Type": "application/json"},
                        timeout=aiohttp.ClientTimeout(total=5)
                    ) as response:
                        if response.status == 200:
                            result = await response.json()
                            if result.get("success"):
                                logger.info(f"‚úÖ Position close recorded in DB: position_id={result.get('position_id')}")
                            else:
                                logger.warning(f"DB recording issue: {result.get('message')}")
                        else:
                            error_text = await response.text()
                            logger.error(f"Failed to record position close in DB: {response.status} - {error_text}")
                    
            except asyncio.TimeoutError:
                logger.warning("Timeout recording position close to DB (non-critical)")
            except Exception as e:
                logger.error(f"Error recording position close to DB: {e}")
                import traceback
                logger.error(f"[DEBUG] Full traceback: {traceback.format_exc()}")
    
            # ===== –ö–û–ù–ï–¶ –ö–û–î–ê –ó–ê–ü–ò–°–ò =====
    
            await send_telegram_alert(
                f"üîÑ **–ü–û–ó–ò–¶–ò–Ø –ó–ê–ö–†–´–¢–ê**\n"
                f"Symbol: {signal.symbol}\n"
                f"Original Side: {position_to_close.get('side', 'Unknown')}\n"
                f"Size: {position_to_close.get('size', 0):.6f}\n"
                f"Mode: {'DEMO' if getattr(self, 'demo_mode', True) else 'LIVE'}"
            )

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —É—Å–ø–µ—Ö–∞
            ##self.system_stats['successful_copies'] += 1

        except Exception as e:
            logger.error(f"Position copy close error: {e}")
            await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –ó–ê–ö–†–´–¢–ò–Ø**: {str(e)}")

    async def _handle_position_modify_for_copy(self, signal):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            logger.info(f"üü° COPYING POSITION MODIFY: {signal.symbol}")

            # –ù–∞—Ö–æ–¥–∏–º –∞–∫—Ç–∏–≤–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
            current_position = None
            if hasattr(self.copy_manager, 'active_positions'):
                current_position = self.copy_manager.active_positions.get(signal.symbol)

            if not current_position:
                logger.warning(f"No position to modify: {signal.symbol}")
                await send_telegram_alert(
                    f"‚ö†Ô∏è **–ù–ï–¢ –ü–û–ó–ò–¶–ò–ò –î–õ–Ø –ò–ó–ú–ï–ù–ï–ù–ò–Ø**\n"
                    f"Symbol: {signal.symbol}\n"
                    "–ü–æ–∑–∏—Ü–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å –µ—â–µ –Ω–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞"
                )
                return

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∏—é)
            try:
                source_balance = await self.base_monitor.source_client.get_balance()
                main_balance   = await self.base_monitor.main_client.get_balance()

                source_position_value = signal.size * signal.price
                source_percentage     = source_position_value / source_balance
                target_value          = main_balance * source_percentage
                new_target_size       = target_value / signal.price

                old_size = float(current_position.get('size', 0))
                logger.info(f"üü° MODIFY CALCULATION: Current {old_size:.6f} -> New {new_target_size:.6f}")

                # DEMO: –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –ù–ò–ß–ï–ì–û –ù–ï —Å—á–∏—Ç–∞–µ–º –∫–∞–∫ "—Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ"
                if getattr(self, 'demo_mode', True):
                    current_position['size'] = new_target_size
                    current_position['last_modified'] = time.time()
                    result_success = False  # –Ω–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞
                else:
                    # TODO: –∑–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–µ–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –¥–æ–≤–µ–¥–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–æ new_target_size
                    # –ø—Ä–∏–º–µ—Ä: self.copy_manager.order_manager.place_adaptive_order(...)
                    logger.info(f"üîÑ LIVE MODE: would modify position to {new_target_size:.6f}")
                    result_success = False  # –ø–æ–∫–∞ —Ä–µ–∞–ª—å–Ω—ã–π modify –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω

            except Exception as e:
                logger.error(f"Position modify calculation error: {e}")
                await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –†–ê–°–ß–ï–¢–ê –ò–ó–ú–ï–ù–ï–ù–ò–Ø**: {str(e)}")
                return

            await send_telegram_alert(
                f"üîÑ **–ü–û–ó–ò–¶–ò–Ø –ò–ó–ú–ï–ù–ï–ù–ê**\n"
                f"Symbol: {signal.symbol}\n"
                f"Old Size: {old_size:.6f}\n"
                f"New Size: {new_target_size:.6f}\n"
                f"Mode: {'DEMO' if getattr(self, 'demo_mode', True) else 'LIVE'}"
            )

            # ‚úî –°—á–∏—Ç–∞–µ–º "—Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ" –¢–û–õ–¨–ö–û –ø—Ä–∏ —Ä–µ–∞–ª—å–Ω–æ–º —É—Å–ø–µ—à–Ω–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ (–∫–æ–≥–¥–∞ –ø–æ—è–≤–∏—Ç—Å—è –æ—Ä–¥–µ—Ä)
            ##if result_success:
                ##self.system_stats['successful_copies'] += 1

        except Exception as e:
            logger.error(f"Position copy modify error: {e}")
            await send_telegram_alert(f"‚ùå **–û–®–ò–ë–ö–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –ò–ó–ú–ï–ù–ï–ù–ò–Ø**: {str(e)}")


    async def handle_position_signal(self, position_data):
        """
        –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø–æ–∑–∏—Ü–∏–π –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
        """
        try:
            # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            logger.info(f"üîÑ Stage2 received position signal: {position_data}")
        
            if not self.system_active or not self.copy_enabled:
                logger.info(f"Stage2 not ready: active={self.system_active}, enabled={self.copy_enabled}")
                return
    
            symbol = position_data.get('symbol', '')
            current_size = float(position_data.get('size', '0'))
            side = position_data.get('side', '')
            price = float(position_data.get('markPrice', '0'))
    
            logger.info(f"üìä Position signal details: {symbol} {side} size={current_size} price={price}")
        
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã
            if symbol == 'TEST':
                return
    
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏
            position_key = f"{symbol}_{side}"
    
            # --- –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–Ø –î–ê–ù–ù–´–• –ü–û–ó–ò–¶–ò–ò (B) ---
            price = safe_float(
                position_data.get("entryPrice")
                or position_data.get("sessionAvgPrice")
                or position_data.get("markPrice")
                or 0
            )
            # --- –ö–û–ù–ï–¶ –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–ò ---

            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º copy_manager.active_positions –≤–º–µ—Å—Ç–æ self.active_positions
            if position_key in self.copy_manager.active_positions:
                # –°—É—â–µ—Å—Ç–≤—É—é—â–∞—è –ø–æ–∑–∏—Ü–∏—è - –ø—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
                prev_size = self.copy_manager.active_positions[position_key].get('size', 0)
                size_delta = current_size - prev_size
            
                logger.info(f"üìà Position change: {symbol} {prev_size:.6f} -> {current_size:.6f} (delta: {size_delta:.6f})")
        
                if abs(size_delta) > 0.001:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ 0.001
                    if size_delta > 0:
                        # –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                        signal = TradingSignal(
                            signal_type=SignalType.POSITION_MODIFY,
                            symbol=symbol,
                            side=side,
                            size=abs(size_delta),
                            price=price,
                            timestamp=time.time(),
                            metadata={
                                'action': 'increase',
                                'prev_size': prev_size,
                                'new_size': current_size,
                                'source': 'websocket'
                            }
                        )
                        logger.info(f"üü° Generated MODIFY signal for increase: {symbol}")
                        await self.process_copy_signal(signal)
                
                    elif current_size == 0:
                        # –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                        signal = TradingSignal(
                            signal_type=SignalType.POSITION_CLOSE,
                            symbol=symbol,
                            side=side,
                            size=prev_size,
                            price=price,
                            timestamp=time.time(),
                            metadata={
                                'action': 'close',
                                'prev_size': prev_size,
                                'source': 'websocket'
                            }
                        )
                        logger.info(f"üî¥ Generated CLOSE signal: {symbol}")
                        await self.process_copy_signal(signal)
                
                    else:
                        # –£–º–µ–Ω—å—à–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                        signal = TradingSignal(
                            signal_type=SignalType.POSITION_MODIFY,
                            symbol=symbol,
                            side=side,
                            size=abs(size_delta),
                            price=price,
                            timestamp=time.time(),
                            metadata={
                                'action': 'decrease',
                                'prev_size': prev_size,
                                'new_size': current_size,
                                'source': 'websocket'
                            }
                        )
                        logger.info(f"üü° Generated MODIFY signal for decrease: {symbol}")
                        await self.process_copy_signal(signal)
            else:
                # –ù–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è
                if current_size > 0:
                    signal = TradingSignal(
                        signal_type=SignalType.POSITION_OPEN,
                        symbol=symbol,
                        side=side,
                        size=current_size,
                        price=price,
                        timestamp=time.time(),
                        metadata={
                            'action': 'open',
                            'source': 'websocket'
                        }
                    )
                    logger.info(f"üü¢ Generated OPEN signal: {symbol}")
                    await self.process_copy_signal(signal)
    
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –º–µ—Å—Ç–µ
            if current_size > 0:
                self.copy_manager.active_positions[position_key] = {
                    'symbol': symbol,
                    'side': side,
                    'size': current_size,
                    'price': price,
                    'last_update': time.time()
                }
                logger.debug(f"Updated position state: {position_key}")
            elif position_key in self.copy_manager.active_positions:
                del self.copy_manager.active_positions[position_key]
                logger.debug(f"Removed position state: {position_key}")
    
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.system_stats['total_signals_processed'] += 1
    
        except Exception as e:
            logger.error(f"Position signal handling error: {e}")
            logger.error(f"Position data: {position_data}")

    def _register_copy_signal_handler(self):
        """–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            # –†–∞—Å—à–∏—Ä—è–µ–º signal processor –∏–∑ –≠—Ç–∞–ø–∞ 1 –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
            original_execute_signal = self.base_monitor.signal_processor._execute_signal_processing
            
            async def enhanced_signal_processing(signal: TradingSignal):
                """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
                # –°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω—è–µ–º –±–∞–∑–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
                await original_execute_signal(signal)
                
                # –ó–∞—Ç–µ–º –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
                if self.copy_enabled and not self.drawdown_controller.emergency_stop_active:
                    await self.process_copy_signal(signal)
                    self.system_stats['total_signals_processed'] += 1
            
            # –ü–æ–¥–º–µ–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
            self.base_monitor.signal_processor._execute_signal_processing = enhanced_signal_processing
            
            logger.info("Copy signal handler registered")
            
        except Exception as e:
            logger.error(f"Copy signal handler registration error: {e}")
    
    async def start_system(self):
        """–ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω—ã–π –∑–∞–ø—É—Å–∫ Stage-2, –∫–æ—Ç–æ—Ä—ã–π —É–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—É—Å–∫–æ–º Stage-1"""
        if getattr(self, "_started", False):
            logger.info("Stage2.start_system() called again ‚Äî ignored (idempotent)")
            return
        self._started = True

        try:
            logger.info("üöÄ Starting Stage 2 Copy Trading System...")
            self.system_stats['start_time'] = time.time()

            # –°–ù–ê–ß–ê–õ–ê –∑–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä Stage-1, —á—Ç–æ–±—ã –æ–Ω —É—Å—Ç–∞–Ω–æ–≤–∏–ª WS –∏ –±—ã–ª –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ
            if not getattr(self.base_monitor, "_started", False):
                self.base_monitor.copy_trading_system = self # –ü–µ—Ä–µ–¥–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Å–µ–±—è –≤ –º–æ–Ω–∏—Ç–æ—Ä
                await self.base_monitor.start()
                logger.info("‚úÖ Base monitor (Stage 1) started successfully.")

            # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –æ—á–µ—Ä–µ–¥–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
            if not self._handlers_registered:
                await self.copy_manager.start_copying()
                self._handlers_registered = True

            # –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ Stage-2
            monitoring_task = asyncio.create_task(self._stage2_monitoring_loop())
            risk_task       = asyncio.create_task(self._risk_monitoring_loop())
            trailing_task   = asyncio.create_task(self._trailing_stop_loop())

            self.system_active = True

            # –ï–¥–∏–Ω–∏—á–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ç–∞—Ä—Ç–µ Stage-2
            await send_telegram_alert(
                "üöÄ –≠–¢–ê–ü 2: –°–ò–°–¢–ï–ú–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø –ó–ê–ü–£–©–ï–ù–ê!\n"
                "‚úÖ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∞–∫—Ç–∏–≤–µ–Ω\n"
                "‚úÖ –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π –≤–∫–ª—é—á–µ–Ω–æ\n"
                "‚úÖ Kelly Criterion –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω\n"
                "‚úÖ Trailing Stop-Loss –≤–∫–ª—é—á–µ–Ω\n"
                "‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å —Ä–∏—Å–∫–æ–≤ –∞–∫—Ç–∏–≤–µ–Ω"
            )

            await asyncio.gather(
                monitoring_task, risk_task, trailing_task,
                return_exceptions=True
            )

        except Exception as e:
            logger.error(f"System startup error: {e}")
            try:
                await send_telegram_alert(f"‚ùå System startup failed: {e}")
            except Exception:
                pass
            raise


    
    async def _stage2_monitoring_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≠—Ç–∞–ø–∞ 2"""
        try:
            while self.system_active:
                current_time = time.time()
                self.system_stats['uptime'] = current_time - self.system_stats['start_time']
                
                # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ç—á–µ—Ç–Ω–æ—Å—Ç—å (–∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç)
                if int(current_time) % 900 == 0:
                    await self._generate_stage2_report()
                
                await asyncio.sleep(30)
                
        except asyncio.CancelledError:
            logger.debug("Stage 2 monitoring loop cancelled")
        except Exception as e:
            logger.error(f"Stage 2 monitoring loop error: {e}")
    
    async def _risk_monitoring_loop(self):
        """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Ä–∏—Å–∫–æ–≤"""
        try:
            while self.system_active:
                current_time = time.time()
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –∏ –ø—Ä–æ—Å–∞–¥–∫—É –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
                if current_time - self.last_balance_check > self.balance_check_interval:
                    await self._check_risk_levels()
                    self.last_balance_check = current_time
                
                await asyncio.sleep(10)
                
        except asyncio.CancelledError:
            logger.debug("Risk monitoring loop cancelled")
        except Exception as e:
            logger.error(f"Risk monitoring loop error: {e}")
    
    async def _trailing_stop_loop(self):
        """–¶–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è Trailing Stop-Loss"""
        try:
            while self.system_active:
                await self.copy_manager.update_trailing_stops()
                await asyncio.sleep(5)  # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
                
        except asyncio.CancelledError:
            logger.debug("Trailing stop loop cancelled")
        except Exception as e:
            logger.error(f"Trailing stop loop error: {e}")
    
    async def _check_risk_levels(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Ä–æ–≤–Ω–µ–π —Ä–∏—Å–∫–∞ —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Å–Ω–∏–º–∫–æ–≤ –±–∞–ª–∞–Ω—Å–∞"""
        try:
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–∞–ª–∞–Ω—Å–µ
            try:
                # ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ (Bybit v5)
                response = await self.base_monitor.main_client.get_wallet_balance("UNIFIED")

                if response and response.get('retCode') == 0:
                    # –ü–∞—Ä—Å–∏–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                    for account in response.get('result', {}).get('list', []):
                        for coin_info in account.get('coin', []):
                            if coin_info.get('coin') == 'USDT':
                                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                                free = float(coin_info.get('walletBalance', 0))       # –°–≤–æ–±–æ–¥–Ω—ã–π –±–∞–ª–∞–Ω—Å
                                locked = float(coin_info.get('totalOrderIM', 0))       # –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –≤ –æ—Ä–¥–µ—Ä–∞—Ö
                                unrealized_pnl = float(coin_info.get('unrealisedPnl', 0))
                                equity = float(coin_info.get('equity', free + locked + unrealized_pnl))

                                # –õ–æ–≥–∏—Ä—É–µ–º —Å–Ω–∏–º–æ–∫ –±–∞–ª–∞–Ω—Å–∞
                                balance_logger.log_balance_snapshot(
                                    account_id=2,  # –û—Å–Ω–æ–≤–Ω–æ–π –∞–∫–∫–∞—É–Ω—Ç
                                    asset='USDT',
                                    free=free,
                                    locked=locked,
                                    equity=equity
                                )

                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º drawdown —Å equity
                                risk_result = await self.drawdown_controller.check_drawdown_limits(equity)

                                if risk_result.get('emergency_stop_required'):
                                    await self._handle_emergency_stop()
                                elif risk_result.get('recovery_mode_required'):
                                    await self._handle_recovery_mode(risk_result['total_drawdown'])

                                return  # –û–±—Ä–∞–±–æ—Ç–∞–ª–∏ USDT, –≤—ã—Ö–æ–¥–∏–º

                else:
                    # –ï—Å–ª–∏ Bybit –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É ‚Äî –¥–∞—ë–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –∏ –∏–¥—ë–º –≤ fallback
                    ret_code = response.get('retCode') if isinstance(response, dict) else 'N/A'
                    ret_msg = response.get('retMsg') if isinstance(response, dict) else 'N/A'
                    logger.warning(f"Wallet-balance retCode={ret_code}, retMsg={ret_msg}; using simple balance fallback")

            except Exception as e:
                logger.warning(f"Failed to get detailed balance, falling back to simple method: {e}")

            # Fallback: –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –º–µ—Ç–æ–¥ –µ—Å–ª–∏ –¥–µ—Ç–∞–ª—å–Ω—ã–π –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
            current_balance = await self.base_monitor.main_client.get_balance()

            if current_balance and current_balance > 0:
                # –õ–æ–≥–∏—Ä—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Å–Ω–∏–º–æ–∫
                balance_logger.log_balance_snapshot(
                    account_id=2,
                    asset='USDT',
                    free=current_balance,
                    locked=0,
                    equity=current_balance
                )

                risk_result = await self.drawdown_controller.check_drawdown_limits(current_balance)

                if risk_result.get('emergency_stop_required'):
                    await self._handle_emergency_stop()
                elif risk_result.get('recovery_mode_required'):
                    await self._handle_recovery_mode(risk_result['total_drawdown'])

        except Exception as e:
            logger.error(f"Risk levels check error: {e}")

    
    async def _handle_emergency_stop(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —ç–∫—Å—Ç—Ä–µ–Ω–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏"""
        try:
            logger.critical("EMERGENCY STOP TRIGGERED - Stopping all trading")
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
            self.copy_enabled = False
            await self.copy_manager.stop_copying()
            
            # –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–∫—Ä—ã—Ç—å –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            await self._close_all_positions()
            
            self.system_stats['emergency_stops'] += 1
            
        except Exception as e:
            logger.error(f"Emergency stop handling error: {e}")
    
    async def _handle_recovery_mode(self, drawdown: float):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∂–∏–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"""
        try:
            logger.warning(f"RECOVERY MODE ACTIVATED - Drawdown: {drawdown:.2%}")
            
            # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
            recovery_params = self.drawdown_controller.calculate_recovery_parameters(drawdown)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (–∑–¥–µ—Å—å –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –ª–æ–≥–∏–∫—É)
            logger.info(f"Recovery parameters: {recovery_params}")
            
            self.system_stats['recovery_activations'] += 1
            
        except Exception as e:
            logger.error(f"Recovery mode handling error: {e}")
    
    async def _close_all_positions(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π (—ç–∫—Å—Ç—Ä–µ–Ω–Ω–∞—è –º–µ—Ä–∞)"""
        try:
            active_positions = await self.base_monitor.main_client.get_positions()
            
            for position in active_positions:
                symbol = position.get('symbol')
                side = position.get('side')
                size = safe_float(position.get('size', 0))
                
                if size > 0:
                    close_side = "Sell" if side == "Buy" else "Buy"
                    
                    # Market –æ—Ä–¥–µ—Ä –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
                    order_data = {
                        "category": "linear",
                        "symbol": symbol,
                        "side": close_side,
                        "orderType": "Market",
                        "qty": str(size),
                        "timeInForce": "IOC"
                    }
                    
                    result = await self.base_monitor.main_client._make_request_with_retry(
                        "POST", "order/create", data=order_data
                    )
                    
                    if result and result.get('retCode') == 0:
                        logger.info(f"Emergency close: {symbol} {close_side} {size}")
                    else:
                        logger.error(f"Emergency close failed: {symbol}")
            
        except Exception as e:
            logger.error(f"Emergency position closing error: {e}")
    
    async def _generate_stage2_report(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –≠—Ç–∞–ø–∞ 2 (—É—Å—Ç–æ–π—á–∏–≤–æ –∫ —Å–µ—Ç–µ–≤—ã–º —Å–±–æ—è–º –∏ –±–µ–∑ await –≤ —Å–ø–æ—Ä–Ω–æ–º –º–µ—Å—Ç–µ)"""
        try:
            # 1) –°–æ–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            copy_stats = self.copy_manager.get_copy_stats()
            risk_stats = self.drawdown_controller.get_risk_stats()
            execution_stats = self.copy_manager.order_manager.get_execution_stats()

            # 2) –ë–∞–ª–∞–Ω—Å –º–æ–∂–µ—Ç –±—ã—Ç—å None –ø—Ä–∏ —Å–µ—Ç–µ–≤—ã—Ö —Å–±–æ—è—Ö -> –Ω–µ –ø–∞–¥–∞–µ–º –Ω–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
            current_balance = await self.base_monitor.main_client.get_balance()
            if current_balance is None:
                balance_str = "N/A"
            else:
                balance_str = f"${current_balance:.2f}"

            uptime_hours = float(self.system_stats.get('uptime', 0.0)) / 3600.0

            # 3) –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç—á—ë—Ç (–±–µ–∑–æ–ø–∞—Å–Ω–æ)
            report = (
                "üìä –û–¢–ß–ï–¢ –≠–¢–ê–ü–ê 2: –°–ò–°–¢–ï–ú–ê –ö–û–ü–ò–†–û–í–ê–ù–ò–Ø\n"
                + "=" * 50 + "\n"
                + f"–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {uptime_hours:.1f}—á\n"
                + f"–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {balance_str}\n\n"

                "üîÑ –ö–û–ü–ò–†–û–í–ê–ù–ò–ï –ü–û–ó–ò–¶–ò–ô:\n"
                f"–†–µ–∂–∏–º: {copy_stats.get('copy_mode')}\n"
                f"–ü–æ–∑–∏—Ü–∏–π —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ: {copy_stats.get('positions_copied', 0)}\n"
                f"–ü–æ–∑–∏—Ü–∏–π –∑–∞–∫—Ä—ã—Ç–æ: {copy_stats.get('positions_closed', 0)}\n"
                f"–ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π: {copy_stats.get('active_positions', 0)}\n"
                f"–£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {float(copy_stats.get('copy_success_rate', 0.0)):.1f}%\n"
                f"–°—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞: {float(copy_stats.get('avg_sync_delay', 0.0)):.2f}s\n"
                f"–û–±—â–∏–π –æ–±—ä–µ–º: ${float(copy_stats.get('total_volume_copied', 0.0)):.2f}\n\n"

                "üõ°Ô∏è –£–ü–†–ê–í–õ–ï–ù–ò–ï –†–ò–°–ö–ê–ú–ò:\n"
                f"–ú–∞–∫—Å. –æ–±—â–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {float(risk_stats.get('max_total_drawdown', 0.0)):.2%}\n"
                f"–ú–∞–∫—Å. –¥–Ω–µ–≤–Ω–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {float(risk_stats.get('max_daily_drawdown', 0.0)):.2%}\n"
                f"–≠–∫—Å—Ç—Ä–µ–Ω–Ω—ã—Ö –æ—Å—Ç–∞–Ω–æ–≤–æ–∫: {int(risk_stats.get('emergency_stops_triggered', 0))}\n"
                f"–†–µ–∂–∏–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è: {'–ê–∫—Ç–∏–≤–µ–Ω' if risk_stats.get('recovery_mode_active') else '–ù–µ–∞–∫—Ç–∏–≤–µ–Ω'}\n\n"

                "üìà TRAILING STOP-LOSS:\n"
                f"–ê–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç–æ–ø–æ–≤: {int(copy_stats.get('trailing_stops_active', 0))}\n\n"

                "üéØ KELLY CRITERION:\n"
                f"–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–æ–∫ Kelly: {int(copy_stats.get('kelly_adjustments', 0))}\n\n"

                "‚ö° –ò–°–ü–û–õ–ù–ï–ù–ò–ï –û–†–î–ï–†–û–í:\n"
            )

            # 4) –¢–æ–ø-5 —Å–∏–º–≤–æ–ª–æ–≤, –±–µ–∑–æ–ø–∞—Å–Ω–æ –±–µ—Ä—ë–º –ø–æ–ª—è
            for symbol, stats in list(execution_stats.items())[:5]:
                succ = int(stats.get('success', 0))
                fail = int(stats.get('failed', 0))
                total_orders = succ + fail
                success_rate = (succ / total_orders * 100.0) if total_orders > 0 else 0.0
                avg_time = float(stats.get('avg_time', 0.0))
                report += f"{symbol}: {success_rate:.1f}% ({avg_time:.2f}s)\n"

            logger.info(report)

            # 5) –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram –Ω–µ —á–∞—â–µ 1 —Ä–∞–∑–∞ –≤ —á–∞—Å –∏ –≤ ¬´–º–∏–Ω—É—Ç—É –ø–æ—Å–ª–µ —á–∞—Å–∞¬ª
            now = time.time()
            if (now - getattr(self, "_last_stage2_report_ts", 0.0) >= 3600.0) and (int(now) % 3600 < 60):
                # –ù–µ –±–ª–æ–∫–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–π –ø–æ—Ç–æ–∫: –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Ñ–æ–Ω–µ
                try:
                    asyncio.create_task(send_telegram_alert(report))
                except RuntimeError:
                    # –µ—Å–ª–∏ —Ü–∏–∫–ª –µ—â—ë –Ω–µ –ø–æ–¥–Ω—è—Ç/–¥—Ä—É–≥–æ–π –∫–æ–Ω—Ç–µ–∫—Å—Ç ‚Äî –±–µ—Ä—ë–º —Ç–µ–∫—É—â–∏–π
                    asyncio.get_event_loop().create_task(send_telegram_alert(report))
                self._last_stage2_report_ts = now

        except Exception as e:
            logger.error(f"Stage 2 report generation error: {e}")

    
    async def stop_system(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            logger.info("Stopping Stage 2 Copy Trading System...")
            
            self.system_active = False
            self.copy_enabled = False
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
            await self.copy_manager.stop_copying()
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∞–∑–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É
            self.base_monitor.should_stop = True
            
            await send_telegram_alert("üõë –≠–¢–ê–ü 2: –°–∏—Å—Ç–µ–º–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")
            
            logger.info("Stage 2 system stopped successfully")
            
        except Exception as e:
            logger.error(f"System stop error: {e}")
    
    def get_system_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        try:
            copy_stats = self.copy_manager.get_copy_stats()
            risk_stats = self.drawdown_controller.get_risk_stats()
            base_stats = {
                'websocket_status': self.base_monitor.websocket_manager.status.value,
                'signal_processor_active': self.base_monitor.signal_processor.processing_active
            }
            
            return {
                'system_active': self.system_active,
                'copy_enabled': self.copy_enabled,
                'uptime': self.system_stats['uptime'],
                'copy_stats': copy_stats,
                'risk_stats': risk_stats,
                'base_system': base_stats,
                'system_stats': self.system_stats
            }
            
        except Exception as e:
            logger.error(f"System status error: {e}")
            return {'error': str(e)}

# ================================
# –¢–û–ß–ö–ê –í–•–û–î–ê –≠–¢–ê–ü–ê 2
# ================================

async def main_stage2():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –≠—Ç–∞–ø–∞ 2"""
    try:
        print("üöÄ –ó–∞–ø—É—Å–∫ –≠—Ç–∞–ø–∞ 2: –°–∏—Å—Ç–µ–º–∞ –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –¢–æ—Ä–≥–æ–≤–ª–∏")
        print("=" * 80)
        print("–ö–û–ú–ü–û–ù–ï–ù–¢–´ –≠–¢–ê–ü–ê 2:")
        print("‚úÖ Kelly Criterion –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –ø–æ–∑–∏—Ü–∏–π")
        print("‚úÖ Adaptive Order Manager –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤")
        print("‚úÖ Dynamic Trailing Stop-Loss –¥–ª—è –∑–∞—â–∏—Ç—ã –ø—Ä–∏–±—ã–ª–∏")
        print("‚úÖ Position Copy Manager –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å–¥–µ–ª–æ–∫")
        print("‚úÖ Drawdown Controller –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏")
        print("‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–∏—Å—Ç–µ–º–æ–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≠—Ç–∞–ø–∞ 1")
        print("=" * 80)
        
        # –°–æ–∑–¥–∞–µ–º –∏ –∑–∞–ø—É—Å–∫–∞–µ–º —Å–∏—Å—Ç–µ–º—É –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
        copy_system = Stage2CopyTradingSystem()
        await copy_system.start_system()
        
    except KeyboardInterrupt:
        logger.info("Stage 2 system stopped by user")
        print("\nüõë –≠—Ç–∞–ø 2 –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        logger.error(f"Critical Stage 2 error: {e}")
        logger.error(f"Full traceback: {traceback.format_exc()}")
        await send_telegram_alert(f"Critical Stage 2 error: {e}")
        print(f"\nüí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≠—Ç–∞–ø–∞ 2: {e}")

if __name__ == "__main__":
    try:
        asyncio.run(main_stage2())
    except KeyboardInterrupt:
        print("\nüõë –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\nüí• –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: {e}")
        print("–£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ:")
        print("1. –§–∞–π–ª enhanced_trading_system_final_fixed.py –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ç–æ–π –∂–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏")
        print("2. –í—Å–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã: pip install numpy pandas scipy")
        print("3. API –∫–ª—é—á–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞—Ö")
